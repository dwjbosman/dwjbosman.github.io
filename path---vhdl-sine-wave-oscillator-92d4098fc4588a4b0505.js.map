{"version":3,"sources":["webpack:///path---vhdl-sine-wave-oscillator-92d4098fc4588a4b0505.js","webpack:///./.cache/json/vhdl-sine-wave-oscillator.json"],"names":["webpackJsonp","469","module","exports","data","markdownRemark","html","timeToRead","excerpt","frontmatter","title","cover","date","category","tags","fields","nextTitle","nextSlug","prevTitle","prevSlug","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,o0YAAAC,WAAA,EAAAC,QAAA,gJAAAC,aAAspZC,MAAA,4BAAAC,MAAA,kBAAAC,KAAA,mBAAAC,SAAA,WAAAC,MAAA,kBAAuIC,QAAWC,UAAA,4BAAAC,SAAA,6BAAAC,UAAA,4BAAAC,SAAA,6BAAAC,KAAA,gCAAsMC,aAAgBD,KAAA","file":"path---vhdl-sine-wave-oscillator-92d4098fc4588a4b0505.js","sourcesContent":["webpackJsonp([36940768073078],{\n\n/***/ 469:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In my last article an VHDL I2S transmitter was presented which allows one to playback arbitrary wave data. Eventually the goal is to develop an additive synthesis engine. The next step involves being able to generate a sine wave.</p>\\n<p>As a starting point I use this <a href=\\\"\\\">VHDL sine generator</a> sub component. This generator is nicely parametrized. You can specify the number of bits in the output resolution as well as the phase input.</p>\\n<p>The additive synthesis engine which is to be developed needs to be able to control the frequency of the oscillator. I am not sure yet on the required frequency resolution. I will pick a reasonable number and keep the formulas general so that the value can be easily changed later. The challenge in the development of this oscillator is to implement the following features:</p>\\n<ul>\\n<li>Configurable design parameter 'frequency resolution', default value 0.01 Hz</li>\\n<li>Real time configurable parameter 'frequency', value between 1 Hz and half the sample rate. </li>\\n<li>No floating point</li>\\n<li>No general divisions</li>\\n<li>Where possible use bit shifts to do multiplication / division.</li>\\n</ul>\\n<h1 id=\\\"theory\\\"><a href=\\\"#theory\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Theory</h1>\\n<p>The sine wave generator subcomponent has two design parameters:</p>\\n<ol>\\n<li>Amplitude resolution: 24 bit</li>\\n<li>Phase space size. This value has to be a power of two and determines the phase resolution as well as frequency resolution. Given a target frequency resolution the minimum required phase space bit width can be determined. </li>\\n<li>Each sample a small step will be made to advance the phase of the sine. This phase step is a rational number and can be represented by a numerator and divisor. The algorithm will calculate the divisor and numeator.</li>\\n</ol>\\n<p>Step 3 has to be performed whenever the frequency is changed while the design is 'running'. Step 2 has to be performed design-time. The next steps calculate the static design-time parameters.</p>\\n<h2 id=\\\"design-time-constants\\\"><a href=\\\"#design-time-constants\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Design time constants</h2>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Frequency resolution: \\ntarget_frequency_resolution = 0.01 Hz\\n\\nSample Rate:          \\nsample_rate       = 48000 Hz\\nmax_frequency     = sample_rate / 2    \\nnax_frequency    -> 24000 Hz\\nPhase space size:\\nphase_space_size  = sample_rate / target_frequency_resolution \\nphase_space_size -> 4800000</code></pre>\\n      </div>\\n<p>The sine generator subcomponent requires the phase space to be a power of two. As 'P' is the minimum required phase space size it is required to round up.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Power of 2 phase space size: \\npower2_phase_space_bits =  ceiling(log(phase_space_size) / log(2))      \\npower2_phase_space_bits -> 23 bits\\npower2_phase_space_size -> 2^23 -> 8388608</code></pre>\\n      </div>\\n<p>This results in a slightly better frequency resolution:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Desired frequency resolution:\\ntarget_frequency_resolution = 0.01 Hz\\n\\nQuantized frequency resolution:\\nquantized_frequency_resolution =  sample_rate / power2_phase_space_size\\nquantized_frequency_resolution -> 0.0057220459</code></pre>\\n      </div>\\n<p>The reciprocal of the frequency resolution is the phase step. At each played back sample at 48 kHz sample rate the phase is increased by the phase step.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Phase step:\\nphase_step  = 1 / quantized_frequency_resolution\\nphase_step -> 174.7626666667\\nphase_step_bits = log2(phase_step)\\nphase_step_bits = 7.449 bits\\nassert: sample_rate * phase_step == power2_phase_space_size</code></pre>\\n      </div>\\n<p>The phase step needs to be rounded to a power of two so that it can be easily used in integer division and multiplication. It is possible to round down if the resulting frequency resolution is still above the target. If not round up:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>power2_phase_step_bits =  floor(log(phase_step)/log(2))      \\npower2_phase_step_bits -> 7 bits\\npower2_phase_step      -> 128\\nfrequency resolution would be: 1/128 -> 0.0078125\\n\\npower2_phase_step_bits =  ceil(log(phase_step)/log(2))      \\npower2_phase_step_bits -> 8 bits\\npower2_phase_step      -> 256\\nfrequency resolution would be: 1/256 -> 0.00390625</code></pre>\\n      </div>\\n<p>With 7 bits the frequency resolution is still above the target. At run-time the frequency of the oscillator can be set by as an integer value by multiplying the target frequency with the scaling factor. Eg. to get 440 Hz, the frequency parameter of the osccillator will be set to 440*128 = 56320.  </p>\\n<p>The combination of the sample<em>rate and power2</em>phase<em>space</em>size values imply a non-integer phase<em>step value (174.76...). The phase</em>step value needs to be scaled up to keep accuracy when using it in division. To determine the number of bits in the scaling factor first the determine the maximum error introduced by quantisation. </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase_step          = trunc(phase_step * phase_step_scaling_factor)\\nquantised_phase_step_error = phase_step - scaled_phase_step / phase_step_scaling_factor \\nmaximum_phase_error        = maximum_frequency * quantised_phase_step_error</code></pre>\\n      </div>\\n<p>This maximum<em>error must be below 1. So the quantised</em>phase<em>step</em>error must be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>max_quantised_phase_step_error       = 1 / maximum_frequency\\nmax_quantised_phase_step_error      -> 0.00004166...\\nmax_quantised_phase_step_error_bits -> 14.5507... bits</code></pre>\\n      </div>\\n<p>This implies the required number of bits in the phase step scaling factor:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase_step               = trunc(phase_step * phase_step_scaling_factor)\\nscaled_phase_step_bits          = ceiling( phase_step_bits + max_quantised_phase_step_error_bits)\\nscaled_phase_step_bits         -> 22\\nphase_step_scaling_factor_bits  = ceiling ( max_quantised_phase_step_error_bits ) \\nphase_step_scaling_factor_bits -> 15\\nphase_step_scaling_factor      -> 2^15 -> 32768\\nscaled_phase_step              -> 5726623</code></pre>\\n      </div>\\n<p>At the maximum frequency of 24000 Hz this gives a phase error of:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>maximum_frequency *  ........</code></pre>\\n      </div>\\n<h2 id=\\\"run-time-parameters\\\"><a href=\\\"#run-time-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Run time parameters</h2>\\n<p>Let's say the frequency to generate is 440.0078125 Hz. Then the input scaled frequency would be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>frequency_scaled = frequency * power2_phase_step\\nfrequency_scaled -> 56321</code></pre>\\n      </div>\\n<p>If it would be possible to use floating point arithmatic the phase step would be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp  = ( power2_phase_space_size / sample_rate ) * frequency</code></pre>\\n      </div>\\n<p>or rewritten:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> ( power2_phase_space_size * frequency ) / sample_rate\\nphase_step_fp -> 76896.93867</code></pre>\\n      </div>\\n<p>The integer version of phase<em>step</em>fp consists of phase<em>step</em>decimal and phase<em>step</em>numerator. Phase<em>step</em>decimal will give the decimal part (in the example 76895) while the fraction (0.57333...) will be specified as a numerator, divisor pair (a rational number). The decimal part is calculated as follows:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase  = frequency_scaled * scaled_phase_step\\nscaled_phase -> 645046814720\\n\\ndecimal_divider_bits  = power2_phase_step_bits + phase_step_scaling_bits\\ndecimal_divider_bits -> 23\\nphase_step_decimal    = shift_right ( scaled_phase, decimal_deivider_bits)\\nphase_step_decimal   -> 76896</code></pre>\\n      </div>\\n<p>As a check the phase<em>step</em>decimal is indeed equal to the decimal part of phase<em>step</em>fp. </p>\\n<p>Now the fractional part is calculated as a rational value. The value consists of a numerator and divisor.  Recall the calculation of phase<em>step</em>fp:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> ( power2_phase_space_size * frequency ) / sample_rate</code></pre>\\n      </div>\\n<p>This value can be converted to a rational number:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_divisor  = sample_rate\\nphase_step_divisor -> 48000\\n\\nusing the integer frequency_scaled in stead of the floating point frequency:\\n\\nphase_step_numerator_incl_decimal  = ( power2_phase_space_size * frequency_scaled ) / power2_phase_step\\nphase_step_numerator_incl_decimal  = shift_right ( power2_phase_space_size * frequency_scaled, power2_phase_step_bits)\\nphase_step_numerator_incl_decimal -> 3691053056</code></pre>\\n      </div>\\n<p>As phase<em>step</em>fp is larger then one the numerator is larger then the divisor. To get the fractional part without the decimal part the decimal value is subtracted:\\n<br>\\nphase<em>step</em>numerator  = phase<em>step</em>numerator<em>incl</em>decimal - phase<em>step</em>decimal * sample<em>rate\\nphase</em>step_numerator -> 45056</p>\\n<p>Lastly assert that the numerator is indeed equal to the fractional part of phase<em>step</em>fp:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> 76896.93867\\nphase_step_numerator / phase_step_divisor -> 0.93867</code></pre>\\n      </div>\\n<p>The sine <a href=\\\"https://docs.google.com/spreadsheets/d/1zl4uNqo22D30khxiX1On5RydeTHjTQGgfvHI6CXL8H8/edit?usp=sharing\\\">phase step</a>  calculations in this section can also be found on Google sheets</p>\\n<h1 id=\\\"implementation\\\"><a href=\\\"#implementation\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Implementation</h1>\\n<p>The implementation will use the calculated values as follows: </p>\\n<ul>\\n<li>Each sample the phase will be increased with the decimal part: phase<em>step</em>decimal</li>\\n<li>Each sample the phase<em>step</em>numerator will be added to a counter. When the counter value is above the phase<em>step</em>divisor value the phase will be advanced by one and the counter is decreased by the divisor.</li>\\n</ul>\",\"timeToRead\":6,\"excerpt\":\"In my last article an VHDL I2S transmitter was presented which allows one to playback arbitrary wave data. Eventually the goal is to develop…\",\"frontmatter\":{\"title\":\"VHDL sine wave oscillator\",\"cover\":\"/logos/wave.jpg\",\"date\":\"2018-09-22 22:00\",\"category\":\"Hardware\",\"tags\":[\"VHDL FPGA DSP\"]},\"fields\":{\"nextTitle\":\"VHDL sine wave oscillator\",\"nextSlug\":\"/vhdl-sine-wave-oscillator\",\"prevTitle\":\"VHDL sine wave oscillator\",\"prevSlug\":\"/vhdl-sine-wave-oscillator\",\"slug\":\"/vhdl-sine-wave-oscillator\"}}},\"pathContext\":{\"slug\":\"/vhdl-sine-wave-oscillator\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---vhdl-sine-wave-oscillator-92d4098fc4588a4b0505.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In my last article an VHDL I2S transmitter was presented which allows one to playback arbitrary wave data. Eventually the goal is to develop an additive synthesis engine. The next step involves being able to generate a sine wave.</p>\\n<p>As a starting point I use this <a href=\\\"\\\">VHDL sine generator</a> sub component. This generator is nicely parametrized. You can specify the number of bits in the output resolution as well as the phase input.</p>\\n<p>The additive synthesis engine which is to be developed needs to be able to control the frequency of the oscillator. I am not sure yet on the required frequency resolution. I will pick a reasonable number and keep the formulas general so that the value can be easily changed later. The challenge in the development of this oscillator is to implement the following features:</p>\\n<ul>\\n<li>Configurable design parameter 'frequency resolution', default value 0.01 Hz</li>\\n<li>Real time configurable parameter 'frequency', value between 1 Hz and half the sample rate. </li>\\n<li>No floating point</li>\\n<li>No general divisions</li>\\n<li>Where possible use bit shifts to do multiplication / division.</li>\\n</ul>\\n<h1 id=\\\"theory\\\"><a href=\\\"#theory\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Theory</h1>\\n<p>The sine wave generator subcomponent has two design parameters:</p>\\n<ol>\\n<li>Amplitude resolution: 24 bit</li>\\n<li>Phase space size. This value has to be a power of two and determines the phase resolution as well as frequency resolution. Given a target frequency resolution the minimum required phase space bit width can be determined. </li>\\n<li>Each sample a small step will be made to advance the phase of the sine. This phase step is a rational number and can be represented by a numerator and divisor. The algorithm will calculate the divisor and numeator.</li>\\n</ol>\\n<p>Step 3 has to be performed whenever the frequency is changed while the design is 'running'. Step 2 has to be performed design-time. The next steps calculate the static design-time parameters.</p>\\n<h2 id=\\\"design-time-constants\\\"><a href=\\\"#design-time-constants\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Design time constants</h2>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Frequency resolution: \\ntarget_frequency_resolution = 0.01 Hz\\n\\nSample Rate:          \\nsample_rate       = 48000 Hz\\nmax_frequency     = sample_rate / 2    \\nnax_frequency    -> 24000 Hz\\nPhase space size:\\nphase_space_size  = sample_rate / target_frequency_resolution \\nphase_space_size -> 4800000</code></pre>\\n      </div>\\n<p>The sine generator subcomponent requires the phase space to be a power of two. As 'P' is the minimum required phase space size it is required to round up.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Power of 2 phase space size: \\npower2_phase_space_bits =  ceiling(log(phase_space_size) / log(2))      \\npower2_phase_space_bits -> 23 bits\\npower2_phase_space_size -> 2^23 -> 8388608</code></pre>\\n      </div>\\n<p>This results in a slightly better frequency resolution:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Desired frequency resolution:\\ntarget_frequency_resolution = 0.01 Hz\\n\\nQuantized frequency resolution:\\nquantized_frequency_resolution =  sample_rate / power2_phase_space_size\\nquantized_frequency_resolution -> 0.0057220459</code></pre>\\n      </div>\\n<p>The reciprocal of the frequency resolution is the phase step. At each played back sample at 48 kHz sample rate the phase is increased by the phase step.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Phase step:\\nphase_step  = 1 / quantized_frequency_resolution\\nphase_step -> 174.7626666667\\nphase_step_bits = log2(phase_step)\\nphase_step_bits = 7.449 bits\\nassert: sample_rate * phase_step == power2_phase_space_size</code></pre>\\n      </div>\\n<p>The phase step needs to be rounded to a power of two so that it can be easily used in integer division and multiplication. It is possible to round down if the resulting frequency resolution is still above the target. If not round up:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>power2_phase_step_bits =  floor(log(phase_step)/log(2))      \\npower2_phase_step_bits -> 7 bits\\npower2_phase_step      -> 128\\nfrequency resolution would be: 1/128 -> 0.0078125\\n\\npower2_phase_step_bits =  ceil(log(phase_step)/log(2))      \\npower2_phase_step_bits -> 8 bits\\npower2_phase_step      -> 256\\nfrequency resolution would be: 1/256 -> 0.00390625</code></pre>\\n      </div>\\n<p>With 7 bits the frequency resolution is still above the target. At run-time the frequency of the oscillator can be set by as an integer value by multiplying the target frequency with the scaling factor. Eg. to get 440 Hz, the frequency parameter of the osccillator will be set to 440*128 = 56320.  </p>\\n<p>The combination of the sample<em>rate and power2</em>phase<em>space</em>size values imply a non-integer phase<em>step value (174.76...). The phase</em>step value needs to be scaled up to keep accuracy when using it in division. To determine the number of bits in the scaling factor first the determine the maximum error introduced by quantisation. </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase_step          = trunc(phase_step * phase_step_scaling_factor)\\nquantised_phase_step_error = phase_step - scaled_phase_step / phase_step_scaling_factor \\nmaximum_phase_error        = maximum_frequency * quantised_phase_step_error</code></pre>\\n      </div>\\n<p>This maximum<em>error must be below 1. So the quantised</em>phase<em>step</em>error must be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>max_quantised_phase_step_error       = 1 / maximum_frequency\\nmax_quantised_phase_step_error      -> 0.00004166...\\nmax_quantised_phase_step_error_bits -> 14.5507... bits</code></pre>\\n      </div>\\n<p>This implies the required number of bits in the phase step scaling factor:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase_step               = trunc(phase_step * phase_step_scaling_factor)\\nscaled_phase_step_bits          = ceiling( phase_step_bits + max_quantised_phase_step_error_bits)\\nscaled_phase_step_bits         -> 22\\nphase_step_scaling_factor_bits  = ceiling ( max_quantised_phase_step_error_bits ) \\nphase_step_scaling_factor_bits -> 15\\nphase_step_scaling_factor      -> 2^15 -> 32768\\nscaled_phase_step              -> 5726623</code></pre>\\n      </div>\\n<p>At the maximum frequency of 24000 Hz this gives a phase error of:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>maximum_frequency *  ........</code></pre>\\n      </div>\\n<h2 id=\\\"run-time-parameters\\\"><a href=\\\"#run-time-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Run time parameters</h2>\\n<p>Let's say the frequency to generate is 440.0078125 Hz. Then the input scaled frequency would be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>frequency_scaled = frequency * power2_phase_step\\nfrequency_scaled -> 56321</code></pre>\\n      </div>\\n<p>If it would be possible to use floating point arithmatic the phase step would be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp  = ( power2_phase_space_size / sample_rate ) * frequency</code></pre>\\n      </div>\\n<p>or rewritten:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> ( power2_phase_space_size * frequency ) / sample_rate\\nphase_step_fp -> 76896.93867</code></pre>\\n      </div>\\n<p>The integer version of phase<em>step</em>fp consists of phase<em>step</em>decimal and phase<em>step</em>numerator. Phase<em>step</em>decimal will give the decimal part (in the example 76895) while the fraction (0.57333...) will be specified as a numerator, divisor pair (a rational number). The decimal part is calculated as follows:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scaled_phase  = frequency_scaled * scaled_phase_step\\nscaled_phase -> 645046814720\\n\\ndecimal_divider_bits  = power2_phase_step_bits + phase_step_scaling_bits\\ndecimal_divider_bits -> 23\\nphase_step_decimal    = shift_right ( scaled_phase, decimal_deivider_bits)\\nphase_step_decimal   -> 76896</code></pre>\\n      </div>\\n<p>As a check the phase<em>step</em>decimal is indeed equal to the decimal part of phase<em>step</em>fp. </p>\\n<p>Now the fractional part is calculated as a rational value. The value consists of a numerator and divisor.  Recall the calculation of phase<em>step</em>fp:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> ( power2_phase_space_size * frequency ) / sample_rate</code></pre>\\n      </div>\\n<p>This value can be converted to a rational number:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_divisor  = sample_rate\\nphase_step_divisor -> 48000\\n\\nusing the integer frequency_scaled in stead of the floating point frequency:\\n\\nphase_step_numerator_incl_decimal  = ( power2_phase_space_size * frequency_scaled ) / power2_phase_step\\nphase_step_numerator_incl_decimal  = shift_right ( power2_phase_space_size * frequency_scaled, power2_phase_step_bits)\\nphase_step_numerator_incl_decimal -> 3691053056</code></pre>\\n      </div>\\n<p>As phase<em>step</em>fp is larger then one the numerator is larger then the divisor. To get the fractional part without the decimal part the decimal value is subtracted:\\n<br>\\nphase<em>step</em>numerator  = phase<em>step</em>numerator<em>incl</em>decimal - phase<em>step</em>decimal * sample<em>rate\\nphase</em>step_numerator -> 45056</p>\\n<p>Lastly assert that the numerator is indeed equal to the fractional part of phase<em>step</em>fp:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>phase_step_fp -> 76896.93867\\nphase_step_numerator / phase_step_divisor -> 0.93867</code></pre>\\n      </div>\\n<p>The sine <a href=\\\"https://docs.google.com/spreadsheets/d/1zl4uNqo22D30khxiX1On5RydeTHjTQGgfvHI6CXL8H8/edit?usp=sharing\\\">phase step</a>  calculations in this section can also be found on Google sheets</p>\\n<h1 id=\\\"implementation\\\"><a href=\\\"#implementation\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Implementation</h1>\\n<p>The implementation will use the calculated values as follows: </p>\\n<ul>\\n<li>Each sample the phase will be increased with the decimal part: phase<em>step</em>decimal</li>\\n<li>Each sample the phase<em>step</em>numerator will be added to a counter. When the counter value is above the phase<em>step</em>divisor value the phase will be advanced by one and the counter is decreased by the divisor.</li>\\n</ul>\",\"timeToRead\":6,\"excerpt\":\"In my last article an VHDL I2S transmitter was presented which allows one to playback arbitrary wave data. Eventually the goal is to develop…\",\"frontmatter\":{\"title\":\"VHDL sine wave oscillator\",\"cover\":\"/logos/wave.jpg\",\"date\":\"2018-09-22 22:00\",\"category\":\"Hardware\",\"tags\":[\"VHDL FPGA DSP\"]},\"fields\":{\"nextTitle\":\"VHDL sine wave oscillator\",\"nextSlug\":\"/vhdl-sine-wave-oscillator\",\"prevTitle\":\"VHDL sine wave oscillator\",\"prevSlug\":\"/vhdl-sine-wave-oscillator\",\"slug\":\"/vhdl-sine-wave-oscillator\"}}},\"pathContext\":{\"slug\":\"/vhdl-sine-wave-oscillator\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/vhdl-sine-wave-oscillator.json\n// module id = 469\n// module chunks = 36940768073078"],"sourceRoot":""}