{"version":3,"sources":["webpack:///path---basic-microblaze-with-bootloader-setup-5c36922ba27b7fbb273e.js","webpack:///./.cache/json/basic-microblaze-with-bootloader-setup.json"],"names":["webpackJsonp","450","module","exports","data","markdownRemark","html","timeToRead","excerpt","frontmatter","title","cover","date","category","tags","fields","nextTitle","nextSlug","prevTitle","prevSlug","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA;AAA8h8BC,WAAA,GAAAC,QAAA,4IAAAC,aAAg0SC,MAAA,yCAAAC,MAAA,0BAAAC,KAAA,mBAAAC,SAAA,OAAAC,MAAA,kBAAwJC,QAAWC,UAAA,aAAAC,SAAA,cAAAC,UAAA,4BAAAC,SAAA,6BAAAC,KAAA,6CAAqLC,aAAgBD,KAAA","file":"path---basic-microblaze-with-bootloader-setup-5c36922ba27b7fbb273e.js","sourcesContent":["webpackJsonp([110947099173558],{\n\n/***/ 450:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Table of Contents</h2>\\n<ul>\\n<li>\\n<p><a href=\\\"#create-the-project\\\">Create the project</a></p>\\n<ul>\\n<li><a href=\\\"#initializing-version-control-git\\\">Initializing version control (git)</a></li>\\n<li><a href=\\\"#create-constraints-file-xdc\\\">Create constraints file (XDC)</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#create-the-block-design\\\">Create the block design</a></p>\\n<ul>\\n<li><a href=\\\"#microblaze\\\">Microblaze</a></li>\\n<li><a href=\\\"#clocking-wizard\\\">Clocking wizard</a></li>\\n<li><a href=\\\"#axi-smartconnect\\\">AXI SmartConnect</a></li>\\n<li><a href=\\\"#axi-gpio\\\">AXI GPIO</a></li>\\n<li><a href=\\\"#axi-uartlite\\\">AXI UARTlite</a></li>\\n<li><a href=\\\"#axi-interrupt-controller\\\">AXI Interrupt controller</a></li>\\n<li><a href=\\\"#axi-timer\\\">AXI Timer</a></li>\\n<li><a href=\\\"#axi-ethernetlite\\\">AXI Ethernetlite</a></li>\\n<li><a href=\\\"#axi-quad-spi\\\">AXI Quad SPI</a></li>\\n<li><a href=\\\"#axi-ddr2-controller\\\">AXI DDR2 controller</a></li>\\n<li><a href=\\\"#address-map\\\">Address map</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#xdc-pin-constraints\\\">XDC pin constraints</a></li>\\n<li><a href=\\\"#synthesize\\\">Synthesize</a></li>\\n<li><a href=\\\"#generate-bit-file\\\">Generate bit file</a></li>\\n<li><a href=\\\"#commit-the-block-design-to-version-control\\\">Commit the block design to version control</a></li>\\n<li>\\n<p><a href=\\\"#sdk-software-development\\\">SDK, software development</a></p>\\n<ul>\\n<li>\\n<p><a href=\\\"#create-bootloader-and-bsp\\\">Create bootloader and BSP.</a></p>\\n<ul>\\n<li><a href=\\\"#configure-bootloader-bsp\\\">Configure Bootloader BSP</a></li>\\n<li><a href=\\\"#configure-bootloader\\\">Configure Bootloader</a></li>\\n<li><a href=\\\"#programming-the-fpga\\\">Programming the FPGA</a></li>\\n<li><a href=\\\"#flashing-the-fpga-bitstream\\\">Flashing the FPGA bitstream.</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#create-user-application\\\">Create user application</a></p>\\n<ul>\\n<li><a href=\\\"#configure-testapp-bsp\\\">Configure TestApp BSP</a></li>\\n<li><a href=\\\"#configure-the-testapp\\\">Configure the TestApp</a></li>\\n<li><a href=\\\"#flashing-the-user-application\\\">Flashing the user application</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#committing-the-sdk-code\\\">Committing the SDK code</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#conclusion\\\">Conclusion</a></li>\\n</ul>\\n<p>In my last <a href=\\\"https://dwjbosman.github.io/...\\\">article</a> a VHDL Sine oscillator was presented. Eventually the goal is to develop an additive synthesis engine. In this article a small step is taken by being able to run C/C++ code on a Microblaze processor.</p>\\n<p>There are quite a number of tutorials about setting up a Microblaze processor. Unfortunately most of these tutorials are either out of date or they are lacking some essential information. Especially most tutorials don't describe the 'why' question. This article shows how to get a Microblaze running on a Nexys4 DDR development kit including the following:</p>\\n<ul>\\n<li>Use of the XX MB DDR2 ram chip</li>\\n<li>UART support for debugging</li>\\n<li>Ethernet support for lwIP stack</li>\\n<li>SPI flash support for bootloading from flash.</li>\\n<li>Use of AXI GPIO for simple LED control</li>\\n</ul>\\n<p>I started following <a href=\\\"https://reference.digilentinc.com/learn/programmable-logic/tutorials/nexys-4-ddr-getting-started-with-microblaze-servers/start\\\">Microblaze server</a> tutorial from Digilent. It misses some information in the block design to complete Ethernet and DDR2 configuration. I used this <a href=\\\"https://www.instructables.com/id/Configuring-the-MIG-7-Series-to-Use-the-DDR-Memory/\\\">MIG7</a> tutorial to implement the DDR2 ram. Lastly I followed this tutorial on <a href=\\\"https://reference.digilentinc.com/learn/programmable-logic/tutorials/htsspisf/start\\\">Bootloading</a> to implement the bootloader.</p>\\n<h1>Create the project</h1>\\n<ul>\\n<li>First set up the project. Add this <a href=\\\"https://github.com/dwjbosman/I2S_sender\\\">Vivado TCL script</a> to your start up scripts. The script will create a project TCL file every time 'git commit' is invoked. The TCL project file will contain relative paths which allows your project to be stored in a version control system. </li>\\n<li>Download and install the <a href=\\\"https://github.com/Digilent/vivado-boards.git\\\">Nexys4 DDR board</a> files.</li>\\n</ul>\\n<p>After Vivado starts click the 'create project' button.</p>\\n<p><img src=\\\"resources/001_start_vivado.png\\\" alt=\\\"Start vivado\\\" title=\\\"Start vivado\\\">\\n<img src=\\\"resources/002_vidado_create_project.png\\\" alt=\\\"Create project\\\" title=\\\"Create project\\\">\\n<img src=\\\"resources/004_vivado_rtl_project.png\\\" alt=\\\"Choose RTL project\\\" title=\\\"Choose RTL project\\\">\\n<img src=\\\"resources/005_vivado_select_nexys4_ddr.png\\\" alt=\\\"Select Nexys4 DDR\\\" title=\\\"Select Nexys4 DDR\\\">\\n<img src=\\\"resources/006_vivado_project_summery.png\\\" alt=\\\"Project summary\\\" title=\\\"Project summary\\\">\\n<img src=\\\"resources/007_vivado_ide.png\\\" alt=\\\"Basc Vivado IDE\\\" title=\\\"Vivado IDE\\\"></p>\\n<p>The image</p>\\n<img alt=\\\"Client Logo\\\" style='width:50px' title=\\\"Client Logo\\\" src='resources/001_start_vivado.png' />\\n<p>Next</p>\\n<h2>Initializing version control (git)</h2>\\n<p>After completing the wizard, open the TCL tab and type the following commands:</p>\\n<ol>\\n<li>go to your project folder: cd /home/<username>/Xilinx/projects/basic_microblaze/</li>\\n<li>create a src and blockdesign dir. The src directory will contain all the files that are under version control: exec mkdir -p src/blockdesign</li>\\n<li>create a directory for vhdl files: exec mkdir -p src/design</li>\\n<li>create a folder for the SDK (C sources): exec mkdir -p src/sdk/workspace</li>\\n<li>create a folder for the SDK hardware definition: exec mkdir -p src/sdk/hardware</li>\\n<li>initialize the repository: git init</li>\\n<li>apply first commit: git commit -am \\\"first commit\\\" </li>\\n</ol>\\n<h2>Create constraints file (XDC)</h2>\\n<p>Add the empty XDC in the  project folder: .../basic_microblaze/src/design/design.xdc. In the TCL window run\\ngit add src/design/design.xdc</p>\\n<h1>Create the block design</h1>\\n<p>First step is to specify the architecture of the synthesized FPGA hardware blocks. Pay careful attention to configuration of the clock wizard, the MIG7 memory generator and polarity of reset signals. </p>\\n<p>Add the block design in the  project folder: /home/<username>/Xilinx/projects/basic_microblaze/src/blockdesign</p>\\n<h2>Microblaze</h2>\\n<p>Click on the '+' button and search for \\\"Microblaze\\\". After adding the Microblaze processor click on it to customize it:</p>\\n<ol>\\n<li>wizard page 1: enable the Debug Module (MDM) and enable caches.</li>\\n<li>wizard page 2: next</li>\\n<li>wizard page 3: select 16 kB instruction cache, and a 16 kB data cache.</li>\\n<li>wizard page 4: next</li>\\n<li>wizard page 5: Enable AXI data interface</li>\\n</ol>\\n<p>A green box will appear containing a link to \\\"Run block automation\\\". Clicking this Vivado will create additional IP blocks to support the Microblaze. When clicking \\\"Run block automation\\\" a settings window will open:</p>\\n<ol>\\n<li>Choose local memory 16 KB</li>\\n<li>Choose cache configuration: 16 KB</li>\\n<li>Choose Debug module Debug Only</li>\\n<li>Select enable Peripheral AXI Port</li>\\n<li>Select enable interrupt controller</li>\\n<li>Choose to create a new clocking wizard (100 MHz)</li>\\n</ol>\\n<p>The block design will now contain a Microblaze, Local memory, Processor System Reset, Interrupt controller (and concat block), Clocking wizard, AXI interconnect.</p>\\n<ol start=\\\"7\\\">\\n<li>Later another Processor System Reset block will be added. Rename the existing one to \\\"cpu_sys_reset\\\".</li>\\n</ol>\\n<h2>Clocking wizard</h2>\\n<p>Double click the \\\"clocking wizard\\\" to customize it:</p>\\n<ol>\\n<li>On the clock options page select \\\"single ended clock capability\\\" for the row \\\"primary\\\".</li>\\n<li>On the output clocks page:\\n2.1. Add two extra output clocks besides the existing 100 MHz clock: 200 MHz and 50 MHz.\\n2.2 Also on the this page choose the reset type: active low</li>\\n<li>Finish the wizard and right click the \\\"clk_in1\\\" port. Select ake inputs external. A new external input will be created. Rename it to \\\"CLK100MHZ\\\"</li>\\n<li>Right click the \\\"resetn\\\" port. Select make inputs external. A new external input will be created. Rename it to \\\"reset_n\\\"</li>\\n<li>Connect the \\\"reset_n\\\" port to the  \\\"ext_reset_n\\\" port of the Processor System Reset block.\\nThese clocks are generated using the FPGA's built in MMCM which can be thought of as a kind of PLL. The 200 MHz will be used for the DDR2 controller, the 50 MHz for the Quad SPI Flash and external Ethernet LAN8720A chip. The reset button in on the Nexys4 DDR will output a '0' when pressed. To use this button for resetting the various IP blocks every reset input port has to be configured as \\\"active low\\\". Renaming the ports is required to match the physical pin constraints in the XDC file. Add the following rows to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN E3 IOSTANDARD LVCMOS33} [get_ports CLK100MHZ]\\ncreate_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports CLK100MHZ]\\nset_property -dict {PACKAGE_PIN C12 IOSTANDARD LVCMOS33} [get_ports reset_n]</p>\\n<h2>AXI SmartConnect</h2>\\n<p>In a first attempt I added a DDR2 controller. The 'run block automation' reappeared. After running it an \\\"AXI SmartConnect\\\" appeared. I wondered why this was a different component comparing it to the \\\"AXI interconnect\\\" created by the Microblaze Block Automation. The documentation notes that both \\\"Axi SmartConnect\\\"  and \\\"Axi interconnect\\\" have similar functionality and that \\\"Axi SmartConnect\\\" supersedes \\\"Axi interconnect\\\". In all the examples I saw using Microblaze and DDR RAM there were two \\\"Axi interconnect/smartconnect\\\" blocks. In this design I will use one to keep things simple. Have to check later how this impacts performance.</p>\\n<ol>\\n<li>Delete the existing \\\"AXI interconnect\\\"</li>\\n<li>Add an \\\"AXI SmartConnect\\\"</li>\\n</ol>\\n<p>Double click the \\\"AXI SmartConnect\\\" it to customize:</p>\\n<ol>\\n<li>Select the number of slaves: 3</li>\\n<li>Select the number of masters: 7</li>\\n<li>Select the number of clocks: 2</li>\\n<li>Enable reset input: has resetn input: 1</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect microblaze M_AXI_DP, M_AXI_DC, M_AXI_IC to the input AXI slave interfaces: S00_AXI, S01_AXI, S02_AXI</li>\\n<li>Connect the \\\"clockin wizard\\\" 100Mhz clock (clk_out1) to the aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"interconnect_aresetn\\\" to the resetn input</li>\\n</ol>\\n<p>The AXI SmartConnect is configures such that all the memory interfacing (including IO mapped peripherals) runs through it. Two clocks are required because the DDR2 controller is part of a different clock domain.</p>\\n<h2>AXI GPIO</h2>\\n<p>The AXI GPIO IP block is used to control general purpose input/output pins. In our case only outputs are used to control an RGB LED on the Nexys4 DDR board. Add the AXI GPIO block, double click to configure:</p>\\n<ol>\\n<li>Select \\\"All outputs\\\"</li>\\n<li>Select \\\"GPIO width\\\" as 3 pins.</li>\\n<li>Select default value: \\\"0x10\\\".</li>\\n<li>Finish the wizard and right click the GPIO port. Select make external. A new external output will be created. Rename it to \\\"GPIO\\\"</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the M00_AXI of the \\\"AXI SmartConnect\\\" to the S_AXI input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the s_axi_aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>Add the following rows to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[0]}]\\nset_property -dict {PACKAGE_PIN R11 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[1]}]\\nset_property -dict {PACKAGE_PIN N16 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[2]}]</p>\\n<p>The GPIO width is chosen to 3 to be able to control the Red, Green and Blue channel of the RGB LED. THe output is renamed to \\\"GPIO\\\" so that physical pin constraints can be configured (later on) in the XDC file.</p>\\n<h2>AXI UARTlite</h2>\\n<p>The AXI UARTlite IP block allows the processor to communicate via serial port to the outside world. The C/C++ print routines will make use of this serial port. Add the IP and customize it by double clicking:</p>\\n<ol>\\n<li>Select 38400 as a Baudrate</li>\\n<li>Finish the wizard and right click the UART port. Select make external. A new external output will be created. Rename it to \\\"UART\\\"</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the M01_AXI of the \\\"AXI SmartConnect\\\" to the S_AXI input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the s_axi_aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>The interrupt pin is not connected.</li>\\n<li>Add the following pin constraints to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN D4 IOSTANDARD LVCMOS33} [get_ports UART_txd]\\nset_property -dict {PACKAGE_PIN C4 IOSTANDARD LVCMOS33} [get_ports UART_rxd]</p>\\n<p>The serial port is accessible via USB. It uses the same USB port which is also used for JTAG and FPGA/Microblaze programming.</p>\\n<h2>AXI Interrupt controller</h2>\\n<p>The interrupt controller signals the Microblaze once an external event needs to be handled by the processor. Interrupts are generated by the Timer and Ethernet component. </p>\\n<ol>\\n<li>Add a Concat block if it is not already connected to the interrupt controller.</li>\\n<li>Connect \\\"dout\\\" of the Concat block to intr of the interrupt controller</li>\\n<li>Connect \\\"interrupt\\\" output of the Interrupt Controller to the Microblaze \\\"interrupt\\\" input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>Connect the \\\"processor_clk\\\" input to \\\"s_axi_aclk\\\".</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"mb_reset\\\" to the processor_rst input.</li>\\n<li>Connect the axi bus \\\"s_axi\\\" input to the \\\"M02_axi\\\" output of the AXI SmartConnect.</li>\\n</ol>\\n<p>Note that the intr input is initially displayed as intr[0:0]. This will update automatically to intr[0:1] once the design is validated.</p>\\n<h2>AXI Timer</h2>\\n<p>The Timer component implements a programmable timer. Add an AXI Time IP block. Configure by double clicking:</p>\\n<ol>\\n<li>The Default settings should be ok.</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the \\\"M03_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</li>\\n<li>Connect the interrupt pin to \\\"in0\\\" of the Concat block (which is connected to the interrupt controller).</li>\\n</ol>\\n<h2>AXI Ethernetlite</h2>\\n<p>The Ethernetlite component presents a memory mapped ethernet device to the Microblaze. In the C user application running on the Microblaze the lwIP stack will be used to connect to the Internet.  The Ethernetlite component presents a MII interface. The Nexys4 DDR contains a LAN8720A chip which already implements part of this interface. That chip presents a so called reduced MII interface. Xilinx has a MII_to_RMII IP block available to convert. Add both the \\\"AXI Ethernetlite\\\" and \\\"Ethernet PHY MII to Reduced MII\\\" to the block design.</p>\\n<p>Configure the AXI Ethernetlite block:</p>\\n<ol>\\n<li>Enable Internal Loopback</li>\\n</ol>\\n<p>Create two external output ports:</p>\\n<ol>\\n<li>Create an output port \\\"ETH_RST_N\\\" of type 'other'.</li>\\n<li>Create an output port \\\"ETH_CLK\\\" of type 'clock'.</li>\\n</ol>\\n<p>Connect the blocks:</p>\\n<ol>\\n<li>Connect the \\\"M04_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</li>\\n<li>Connect the interrupt \\\"ip2intc_irpt\\\" pin to \\\"in1\\\" of the Concat block (which is connected to the interrupt controller).</li>\\n<li>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ref_clk\\\" pin.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ETH_CLK\\\" external pin.</li>\\n<li>Connect the Ethernetlite port \\\"MII\\\" to the \\\"MII\\\" port of the MII_to_RMII block.</li>\\n<li>Right click the \\\"MDIO\\\" port, make it external. Rename it to \\\"MDIO\\\"</li>\\n<li>Right click the \\\"RMII_PHY_M\\\" port, make it external. Rename to \\\"RMII_PHY_M\\\".</li>\\n<li>Expand the \\\"MII\\\" port of the Ethernetlite device.\\n9.1 Connect the \\\"phy<em>rst</em>n\\\" pin of the MII bus to the \\\"rst<em>n</em>rmii\\\" of the MII_to_RMII block.\\n9.2 Connect the \\\"phy<em>rst</em>n\\\" pin of the MII bus to the \\\"ETH<em>RST</em>N\\\" external pin.\\n9.3 Collapse the \\\"MII\\\" port.</li>\\n<li>Add the following constraints to the XDC file:\\n`\\nset_property -dict {PACKAGE_PIN C9 IOSTANDARD LVCMOS33} [get_ports MDIO_mdc]\\nset_property -dict {PACKAGE_PIN A9 IOSTANDARD LVCMOS33} [get_ports MDIO_mdio_io]\\nset_property -dict {PACKAGE_PIN B3 IOSTANDARD LVCMOS33} [get_ports ETH_RST_N]\\nset_property -dict {PACKAGE_PIN D9 IOSTANDARD LVCMOS33} [get_ports RMII_PHY<em>M\\\\</em>crs_dv]\\nset_property -dict {PACKAGE_PIN C10 IOSTANDARD LVCMOS33} [get_ports RMII_PHY<em>M\\\\</em>rx_er]\\nset_property -dict {PACKAGE_PIN C11 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY<em>M\\\\</em>rxd[0]}]\\nset_property -dict {PACKAGE_PIN D10 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY<em>M\\\\</em>rxd[1]}]\\nset_property -dict {PACKAGE_PIN B9 IOSTANDARD LVCMOS33} [get_ports RMII_PHY_M_tx_en]\\nset_property -dict {PACKAGE_PIN A10 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY_M_txd[0]}]\\nset_property -dict {PACKAGE_PIN A8 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY_M_txd[1]}]\\nset_property -dict {PACKAGE_PIN D5 IOSTANDARD LVCMOS33} [get_ports ETH_CLK]\\n#set_property -dict { PACKAGE_PIN B8    IOSTANDARD LVCMOS33 } [get_ports { ETH_INTN }]; #IO_L12P_T1_MRCC_16 Sch=eth_intn</li>\\n</ol>\\n<p>In most tutorials the 50MHz clock is used to drive the LANxxx chip and the MII_to_RMII block. According to some recommendations the  MII_to_RMII block introduces a clock delay. Ideally the clocking wizard should be used to create two 50 MHz clocks, one with a phase delay. The un-delayed clock is connected to the MII_to_RMII block. The delayed clock is connected to the LANxxx chip. Furthermore there is a discussion if the LANxxx can be clocked used a synthesized 50MHz clock as there the clock jitter would be outside the LANxxx requirements.  </p>\\n<h2>AXI Quad SPI</h2>\\n<p>The Quad SPI component is connected to the external Quad SPI Flash (A Spansion S25FL128S). It allows the FPGA to retrieve its bit stream from the Flash chip. Furthermore the Microblaze will be able to boot the user application from flash. Add a Quad SPI IP block and configure it:</p>\\n<ol>\\n<li>Select mode: quad</li>\\n<li>Select the Spansion slave device.</li>\\n</ol>\\n<p>Connect the Quad SPI block as follows:</p>\\n<ol>\\n<li>\\n<p>Connect the \\\"M05_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</p>\\n</li>\\n<li>\\n<p>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</p>\\n</li>\\n<li>\\n<p>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</p>\\n</li>\\n<li>\\n<p>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ext_spi_clk\\\" pin.</p>\\n</li>\\n<li>\\n<p>Right click the \\\"SPI_0\\\" port, make it external and rename to \\\"QSPI_FLASH\\\".</p>\\n</li>\\n<li>\\n<p>Add the following pin constraints to the XDC file:</p>\\n<pre><code>set\\\\_property -dict {PACKAGE\\\\_PIN K17 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io0\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN K18 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io1\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN L14 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io2\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN M14 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io3\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN L13 IOSTANDARD LVCMOS33} [get\\\\_ports {QSPI\\\\_FLASH\\\\_ss\\\\_io[0]}]\\n</code></pre>\\n</li>\\n</ol>\\n<h2>AXI DDR2 controller</h2>\\n<p>The Memory Interface Generator (MIG7) is used to create a DDR2 controller for the Micron MT47H64M16HR-25:H RAM chip on the Nexys4 DDR board. The Microblaze will use a BRAM based bootloader to copy the user application from Flash to DDR2 Ram. The DDR2 controller requires very precise timing parameters. These are specified in the <a href=\\\"\\\">DDR2 RAM tutorial</a>. Add a MIG7 component and double click to configure:</p>\\n<ol>\\n<li>At this introduction page click Next.</li>\\n<li>Again click next.</li>\\n<li>Select the pin compatible FPGA. The Nexys4 DDR uses the xc7a100ti-csg324.</li>\\n<li>Choose DDR2 as controller type.</li>\\n<li>On the \\\"Controller options\\\" page select:\\n5.1. Clock period: 3077\\n5.2. Memory part: MT47H64M16HR-25E\\n5.3. Datawidth: 16 bits\\n5.4. Ordering: Normal</li>\\n<li>On the \\\"AXI Parameter\\\" page configure the AXI interface:\\n6.1. Data width: 128\\n6.2. Enable narrow burst support (set to one).</li>\\n<li>On the \\\"Memory Options\\\" page choose:\\n7.1. Set the \\\"input clock period\\\" to 100 MHz. If this setting is missing chances are that you run across a bug in the Memory Interface Generator (MIG7). When running Vivado 2018.2 from Ubuntu use the right locale settings. Restart Vivado from the terminal and first execute: export LC<em>NUMERIC=en</em>US.utf8\\n7.2.  RTT-ODT to be 50 ohms. </li>\\n<li>On the \\\"FPGA options\\\" page:\\n8.1. select \\\"no buffer\\\" for both system clock and reference clock. \\\"no buffer\\\" means that we can connect clocks generated by the clocking wizard.\\n8.2. Set the system reset polarity to active low.\\n8.3. Enable usage of \\\"Internal vref\\\".</li>\\n<li>On the \\\"Extended FPGA options\\\" choose the Internal termination impedance to be 50 omhs.</li>\\n<li>On the \\\"IO Planning\\\" page select fixed pin out as we want to connect the controller to the external RAM chip.</li>\\n<li>On the \\\"Pin selection\\\" page, type the pin numbers, next click validate. Refer to the XDC constraints below for the actual pin values. The pin selection page does not fit on one page, and you have to scroll to get to all the pins. Be care full when scrolling: scrolling when the mouse is above a pin selection drop down changes the pin!</li>\\n<li>On the \\\"System signals\\\" do not select anything.</li>\\n<li>Verify that the summary report is similar to the screenshot.</li>\\n<li>The last pages \\\"simulation options:\\\": accept, \\\"pcb information\\\": next, \\\"design notes\\\": generate.</li>\\n</ol>\\n<p>The DDR RAM controller will generate its own clock on the \\\"ui_clk\\\" pin. The DDR RAM controller needs its own system reset logic as part of this clock domain. Add another \\\"Processor System Reset\\\", rename it to FPGA_sys_reset\\\".</p>\\n<p>Connect the DDR RAM controller:</p>\\n<ol>\\n<li>Connect the AXI SmartConnect pin \\\"M06\\\\AXI\\\" to the S_AXI pin.</li>\\n<li>Connect the external \\\"reset_n\\\" pin to the \\\"sys_rst\\\" pin of the FPGA_sys_reset block.</li>\\n<li>Connect the clocking wizard \\\"clk_out1\\\" (100 MHz) clock to \\\"sys_clk_i\\\" of the Ram controller.</li>\\n<li>Connect the clocking wizard \\\"clk_out2\\\" (200 MHz) clock to \\\"clk_ref_i\\\" of the RAM controller. </li>\\n<li>Right click the DDR controller \\\"DDR2\\\" pin and make it external. Rename the external pin to \\\"DDR2\\\".</li>\\n<li>Connect the DDR controller \\\"ui_clk_sync_rst\\\" to the \\\"ext_reset_in\\\" of the FPGA_sys_reset block.</li>\\n<li>Connect the DDR controller \\\"ui_clk\\\" clock to the \\\"slowest_sync_clk\\\" of the FPGA_sys_reset block.</li>\\n<li>Connect this clock also to the \\\"aclk1\\\" pin of the AXI SmartConnect.</li>\\n<li>Connect the \\\"mmcm_locked\\\" of the DDR Controller to the  \\\"dcm_locked\\\" pin of the FPGA_sys_reset block.</li>\\n<li>The DDR Controller pin \\\"int_calib_complete\\\" is left unconnected.</li>\\n<li>Connect the FPGA_sys_reset pin \\\"peripheral_aresetn\\\" to the DDR controller \\\"aresetn\\\" pin. </li>\\n</ol>\\n<p>In some articles it is specified that one should not use a clocking wizard generated clock connected to the DDR controller as it would have too much jitter. In spite of this advice I have used the 200 MHz output of the clock wizard. The following pin constraints are required connecting the DDR RAM chip.</p>\\n<pre><code>    set\\\\_property -dict {PACKAGE\\\\_PIN R7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R8 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[3]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[4]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[5]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[6]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[7]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[8]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[9]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[10]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[11]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[12]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[13]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[14]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[15]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dm[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dm[1]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U9 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_p[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V9 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_n[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U2 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_p[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V2 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_n[1]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[12]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN K5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[11]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[10]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[9]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[8]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[7]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[6]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[5]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[4]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[3]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[0]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[0]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L6 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ck\\\\_p[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L5 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ck\\\\_n[0]}]\\n\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_ras\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_cas\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_we\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_cke[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_odt[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN K6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_cs\\\\_n[0]}]\\n</code></pre>\\n<h2>Address map</h2>\\n<p>The connected AXI devices are either memory type devices or memory mapped IO devices. We have to specify the Microblaze memory map so that the AXI devices can be accessed by the bootloader and user application. Click the address editor tab.</p>\\n<ol>\\n<li>Right click Data area, unmapped slaves. For each of the following devices select assign address: ethernetlite, gpio, uartlite, timer, quad spi, mig7.</li>\\n<li>The  \\\"Instructions\\\" mapped devices should only contain the local memory and the mig7 device. Select any other mapped devices and rigth click \\\"exclude\\\". </li>\\n</ol>\\n<p>Check that the Microblaze local memory sections for both data and instructions are at least 32 kB.</p>\\n<h1>XDC pin constraints</h1>\\n<p>The XDC file specifies constraints on the physical FPGA pins. Digilent provides a XDC file for the Nexys4 DDR. This file is adapted to map the input and output ports of the block design to physical pins. The [XDC constraints file] is based upon a reference of Digilent. When the block design is completed and synthesized you can run the \\\"get_ports\\\" command in the tcl window. The names of all the different block design input and output pins will then be displayed. These names have to be added to the XDC file. So if you run get_ports and \\\"OUTPUT_X\\\" is displayed then the XDC should contain a row (change the IOStandard and PACKAGE_PIN to suit your needs):</p>\\n<p>set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33} [get_ports OUTPUT_X]</p>\\n<p>Some additional constraints are required to get rid of a warning:\\nset_property CFGBVS VCCO [current_design]\\nset_property CONFIG_VOLTAGE 3.3 [current_design]</p>\\n<h1>Synthesize</h1>\\n<p>Right click \\\"mb_design\\\" in the sources pane. Click \\\"generate HDL wrapper\\\", select \\\"Let Vivado manage wrapper...\\\"</p>\\n<p>Click \\\"Run synthesis\\\" in the \\\"Flow Navigator\\\".\\nClick \\\"Run implementation\\\" ....</p>\\n<p>Click \\\"Open implemented design\\\" and select the IO ports tab. If the XDC contains no errors. It should look like the following screenshot.</p>\\n<h1>Generate bit file</h1>\\n<p>Later on the FPGA bit stream will be flashed on the Quad SPI Flash device. In order to reduce the size of the bit stream and speed up booting the bit stream can be compressed. Turn compression on by adding this to the XDC file.</p>\\n<p>Open the tools -> settings menu. Select bit stream options under project settings. Tick the \\\"-bin_file\\\" option. Open \\\"additional settings\\\" and tick \\\"enable compression\\\". A constraint will be added automatically to the XDC file:</p>\\n<p>set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]</p>\\n<p>Run the bit stream generator.</p>\\n<h1>Commit the block design to version control</h1>\\n<p>Store the current version of the  block design inside version control:</p>\\n<ol>\\n<li>git add src/blockdesign/mb_design/*</li>\\n<li>check with git status that no files under src are \\\"untracked\\\". If needed use \\\"git add\\\" to add remaining untracked files under src. Do not add these folders: basici_microblaze.cache/, basic_microblaze.hw/, basic_microblaze.runs/, basic_microblaze.xpr</li>\\n<li>git commit -am \\\"Block design done\\\"</li>\\n</ol>\\n<h1>SDK, software development</h1>\\n<p>First export the hardware definition. Select the File menu -> export -> export hardware. Enable \\\"include bit stream\\\". Choose the src/sdk/hardware folder.</p>\\n<p>Click launch \\\"SDK\\\" from the project menu. Choose the relevant src/sdk/workspace folder for as workspace. Vivado will start the SDK which is the Eclipse C/C++ development IDE. The workspace will contain the hardware definition \\\"mb_design_wrapper....\\\". Click the \\\"system.hdf\\\" file and check that the memory map is correct.</p>\\n<h2>Create bootloader and BSP.</h2>\\n<p>Create a new \\\"Application project\\\" named \\\"Bootloader\\\". In the \\\"Target software\\\" pane select \\\"Create new\\\" board support package. Name the BSP \\\"Bootloader_bsp\\\". Click \\\"next\\\" and select the \\\"SREC SPI bootloader\\\" template. Click \\\"Finish\\\".</p>\\n<h3>Configure Bootloader BSP</h3>\\n<p>Open the Bootloader_bsp project and open \\\"system.mss\\\". Click \\\"Modify this BSP's Settings\\\". Select \\\"xilisf\\\" in the navigation tree view. Set the \\\"serial_flash_family\\\" type to 5 (Spansion). Click \\\"Regenerate BSP sources\\\". </p>\\n<h3>Configure Bootloader</h3>\\n<p>Open the \\\"Bootloader\\\" project and edit the \\\"blconfig.h\\\" file. The bootloader needs to know the address in SPI flash where the user application resides. Remove the warning and change the \\\"FLASH_IMAGE_BASEADDR\\\" to 0x003D0900. Select the linker \\\"ldscript.ld\\\" file. Set the stack size to 0x200. Check that all segments are assigned to BRAM local memory (and not the external DDR RAM as this memory will receive the user application loaded from the Flash memory). </p>\\n<p>In bootloader.c check that SPI_DEVICE_ID is set to XPAR_SPI_0_DEVICE_ID. The warning line above it can then be removed.</p>\\n<p>In bootloader.c the VERBOSE flag should be defined (by default). This will cause the bootloader to print messages while the bootloading is in progress. The print output will be streamed over the UARTlite interface. The print commands unfortunately slow down the bootloading. A small modification helps. Replace the contents of the function \\\"display_progress\\\" by:</p>\\n<pre><code>print(\\\".\\\")\\n</code></pre>\\n<p>This will speedup things while still giving some insight in the bootloading progress. After saving Eclipse will rebuild the Bootloader. If all is well the Bootloader should compile without errors now.</p>\\n<h3>Programming the FPGA</h3>\\n<p>In this step the hardware design including bootloader will be programmed into flash such that the FPGA loads it every time it boots. Configure the SPI jumper on the Nexys4 DDR development kit. This allows the FPGA to load its bit file from the SPI flash. The FPGA bit file contains the configuration of the FPGA including initial contents of the Microblaze local BRAM.  Next connect the Nexys4 DDR board via the JTAG usb connector. Start a serial terminal (eg. gtkterm) and select the port (eg. /dev/ttyUSB1) and set the baud rate to 38400 (as configured in the UARTlite block design).</p>\\n<p>Run the program FPGA command from the Xilinx menu. Select the bootloader.elf file (in the Bootloader/Debug project) in stead of \\\"bootloop\\\". Selecting \\\"program\\\" will generate a download.bit file in the \\\"mb_design_wrapper_hw_platform_0\\\" project. </p>\\n<p>After the programming completes, in the serial terminal you should see the bootloader starting (and failing).</p>\\n<h3>Flashing the FPGA bitstream.</h3>\\n<p>Next click the \\\"Program Flash\\\" menu item in the Xilinx menu. Select the download.bit files as \\\"image file\\\". The offset should be 0. The flash type is \\\"s25fl128sxxxxx0-spi-x1_x2_x4\\\". Check \\\"verify after flash\\\". And finish by clicking \\\"Program\\\".</p>\\n<p>After flashing you can restart the Nexys4 DDR by pressing the \\\"prog\\\" button. Again the bootloader should start and fail. Note that while the FPGA can load its bit file from flash it can also still be programmed as usual using JTAG.</p>\\n<h2>Create user application</h2>\\n<p>Create a new project, named TestApp. Select Create new board support package named \\\"TestApp_bsp\\\". Click next and select the \\\"Peripheral tests\\\" template.</p>\\n<h3>Configure TestApp BSP</h3>\\n<p>Open the TestApp_bsp project and open \\\"system.mss\\\". Click \\\"Modify this BSP's Settings\\\". Enable \\\"xilisf\\\" and \\\"lwip202\\\" in the supported libraries pane. Select \\\"xilisf\\\" in the navigation tree view. Set the \\\"serial_flash_family\\\" type to 5 (Spansion). S</p>\\n<p>Click \\\"Regenerate BSP sources\\\". Probably the build will fail. There is a bug in Vivado 2018.2 lwip202, it does not define some xadapter code required to compile using EthernetLite. There is a <a href=\\\"\\\">patch</a> available. The patch has been applied manually in the example repository. Be care full not to regenerate the BSP sources as this will remove the patch.</p>\\n<p>The changes can be viewed by looking at this diff: git diff 69b53308d4d4690ab77b53d72262df3ee429e0b d45cd8645e9563a86cef6648e0a15483d39f63f9 '*.c'</p>\\n<h3>Configure the TestApp</h3>\\n<p>The peripherial test application does not need any configuring.</p>\\n<h3>Flashing the user application</h3>\\n<p>Click the \\\"Program Flash\\\" menu item in the Xilinx menu. Select the TestApp.elf file \\\"image file\\\". The offset should be 0x003D0900 (as configured in the bootloader). The flash type is \\\"s25fl128sxxxxx0-spi-x1_x2_x4\\\". Tick \\\"convert elf file to bootable SREC...\\\". Check \\\"verify after flash\\\". And finish by clicking \\\"Program\\\".</p>\\n<p>Reset the Nexys4 DDR by pressing the \\\"prog\\\" button. The bootloader should start loading and eventually run the user application. The user application will print various test messages. The RGB LED connected to the GPIO should react to one of the tests. The last tests will test the Ethernetlite interface (you'll see the Ethernet LEDs blinking twice).</p>\\n<h2>Committing the SDK code</h2>\\n<p>First add .gitignore files to a number of folders to ignore logging files:</p>\\n<p>  src/sdk/workspace/Bootloader_bsp/.gitignore:\\n*.o\\n*.a</p>\\n<p>  src/sdk/workspace/TestApp_bsp/.gitignore:\\n*.o\\n*.a</p>\\n<p>  src/sdk/workspace/mb<em>design</em>wrapper<em>hw</em>platform_0/.gitignore:\\ncache</p>\\n<p>  src/sdk/workspace/.metadata/.gitignore:\\n*.log\\n.lock</p>\\n<p>  src/sdk/.gitignore:\\n*.jou\\n*.log</p>\\n<p>  git add src/sdk/hardware/mb_design_wrapper.hdf\\ngit add src/sdk/workspace/Bootloader\\ngit add src/sdk/workspace/Bootloader_bsp\\ngit add src/sdk/workspace/TestApp\\ngit add src/sdk/workspace/TestApp_bsp\\ngit add src/sdk/workspace/mb_design_wrapper_hw_platform_0\\ngit add src/sdk/workpace/.metadata</p>\\n<p>  git commit --message \\\"Added bootloader and test application with patched lwip202\\\"</p>\\n<h1>Conclusion</h1>\\n<ol>\\n<li>Creating the basic Microblaze architecture running requires many configuration steps. While writing this tutorial I had one working reference project and created a new project describing each step. The first time I ended up with a bootloader that did not fit in the BRAM. Somehow, somewhere the Microblaze cache size was set to 16 kB, instead of the required 32 kB. I suspect the block automation step to be the culprit. Luckily by checking the linker script in the SDK this was easy to find and correct.</li>\\n<li>When working in Linux check your Locale settings as described in the tutorial. If set wrongly the MIG7 wizard will not snow essential settings.</li>\\n<li>The Eclipse SDK crashed a few times resulting in a locked SDK which could not be restarted. Remove .lock files from the .metadata in src/sdk/workspace to get it working again. </li>\\n</ol>\\n<p>The VHDL code can be found in the <a href=\\\"https://github.com/dwjbosman/basic_microblaze\\\">Basic_microblaze</a> repository.</p>\",\"timeToRead\":28,\"excerpt\":\"Table of Contents Create the project Initializing version control (git) Create constraints file (XDC) Create the block design Microblazeâ€¦\",\"frontmatter\":{\"title\":\"Basic Microblaze with bootloader setup\",\"cover\":\"/logos/sine-article.jpg\",\"date\":\"2018-11-01 09:00\",\"category\":\"FPGA\",\"tags\":[\"VHDL FPGA SDK\"]},\"fields\":{\"nextTitle\":\"First Post\",\"nextSlug\":\"/first-post\",\"prevTitle\":\"VHDL sine wave oscillator\",\"prevSlug\":\"/vhdl-sine-wave-oscillator\",\"slug\":\"/basic-microblaze-with-bootloader-setup\"}}},\"pathContext\":{\"slug\":\"/basic-microblaze-with-bootloader-setup\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---basic-microblaze-with-bootloader-setup-5c36922ba27b7fbb273e.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Table of Contents</h2>\\n<ul>\\n<li>\\n<p><a href=\\\"#create-the-project\\\">Create the project</a></p>\\n<ul>\\n<li><a href=\\\"#initializing-version-control-git\\\">Initializing version control (git)</a></li>\\n<li><a href=\\\"#create-constraints-file-xdc\\\">Create constraints file (XDC)</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#create-the-block-design\\\">Create the block design</a></p>\\n<ul>\\n<li><a href=\\\"#microblaze\\\">Microblaze</a></li>\\n<li><a href=\\\"#clocking-wizard\\\">Clocking wizard</a></li>\\n<li><a href=\\\"#axi-smartconnect\\\">AXI SmartConnect</a></li>\\n<li><a href=\\\"#axi-gpio\\\">AXI GPIO</a></li>\\n<li><a href=\\\"#axi-uartlite\\\">AXI UARTlite</a></li>\\n<li><a href=\\\"#axi-interrupt-controller\\\">AXI Interrupt controller</a></li>\\n<li><a href=\\\"#axi-timer\\\">AXI Timer</a></li>\\n<li><a href=\\\"#axi-ethernetlite\\\">AXI Ethernetlite</a></li>\\n<li><a href=\\\"#axi-quad-spi\\\">AXI Quad SPI</a></li>\\n<li><a href=\\\"#axi-ddr2-controller\\\">AXI DDR2 controller</a></li>\\n<li><a href=\\\"#address-map\\\">Address map</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#xdc-pin-constraints\\\">XDC pin constraints</a></li>\\n<li><a href=\\\"#synthesize\\\">Synthesize</a></li>\\n<li><a href=\\\"#generate-bit-file\\\">Generate bit file</a></li>\\n<li><a href=\\\"#commit-the-block-design-to-version-control\\\">Commit the block design to version control</a></li>\\n<li>\\n<p><a href=\\\"#sdk-software-development\\\">SDK, software development</a></p>\\n<ul>\\n<li>\\n<p><a href=\\\"#create-bootloader-and-bsp\\\">Create bootloader and BSP.</a></p>\\n<ul>\\n<li><a href=\\\"#configure-bootloader-bsp\\\">Configure Bootloader BSP</a></li>\\n<li><a href=\\\"#configure-bootloader\\\">Configure Bootloader</a></li>\\n<li><a href=\\\"#programming-the-fpga\\\">Programming the FPGA</a></li>\\n<li><a href=\\\"#flashing-the-fpga-bitstream\\\">Flashing the FPGA bitstream.</a></li>\\n</ul>\\n</li>\\n<li>\\n<p><a href=\\\"#create-user-application\\\">Create user application</a></p>\\n<ul>\\n<li><a href=\\\"#configure-testapp-bsp\\\">Configure TestApp BSP</a></li>\\n<li><a href=\\\"#configure-the-testapp\\\">Configure the TestApp</a></li>\\n<li><a href=\\\"#flashing-the-user-application\\\">Flashing the user application</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#committing-the-sdk-code\\\">Committing the SDK code</a></li>\\n</ul>\\n</li>\\n<li><a href=\\\"#conclusion\\\">Conclusion</a></li>\\n</ul>\\n<p>In my last <a href=\\\"https://dwjbosman.github.io/...\\\">article</a> a VHDL Sine oscillator was presented. Eventually the goal is to develop an additive synthesis engine. In this article a small step is taken by being able to run C/C++ code on a Microblaze processor.</p>\\n<p>There are quite a number of tutorials about setting up a Microblaze processor. Unfortunately most of these tutorials are either out of date or they are lacking some essential information. Especially most tutorials don't describe the 'why' question. This article shows how to get a Microblaze running on a Nexys4 DDR development kit including the following:</p>\\n<ul>\\n<li>Use of the XX MB DDR2 ram chip</li>\\n<li>UART support for debugging</li>\\n<li>Ethernet support for lwIP stack</li>\\n<li>SPI flash support for bootloading from flash.</li>\\n<li>Use of AXI GPIO for simple LED control</li>\\n</ul>\\n<p>I started following <a href=\\\"https://reference.digilentinc.com/learn/programmable-logic/tutorials/nexys-4-ddr-getting-started-with-microblaze-servers/start\\\">Microblaze server</a> tutorial from Digilent. It misses some information in the block design to complete Ethernet and DDR2 configuration. I used this <a href=\\\"https://www.instructables.com/id/Configuring-the-MIG-7-Series-to-Use-the-DDR-Memory/\\\">MIG7</a> tutorial to implement the DDR2 ram. Lastly I followed this tutorial on <a href=\\\"https://reference.digilentinc.com/learn/programmable-logic/tutorials/htsspisf/start\\\">Bootloading</a> to implement the bootloader.</p>\\n<h1>Create the project</h1>\\n<ul>\\n<li>First set up the project. Add this <a href=\\\"https://github.com/dwjbosman/I2S_sender\\\">Vivado TCL script</a> to your start up scripts. The script will create a project TCL file every time 'git commit' is invoked. The TCL project file will contain relative paths which allows your project to be stored in a version control system. </li>\\n<li>Download and install the <a href=\\\"https://github.com/Digilent/vivado-boards.git\\\">Nexys4 DDR board</a> files.</li>\\n</ul>\\n<p>After Vivado starts click the 'create project' button.</p>\\n<p><img src=\\\"resources/001_start_vivado.png\\\" alt=\\\"Start vivado\\\" title=\\\"Start vivado\\\">\\n<img src=\\\"resources/002_vidado_create_project.png\\\" alt=\\\"Create project\\\" title=\\\"Create project\\\">\\n<img src=\\\"resources/004_vivado_rtl_project.png\\\" alt=\\\"Choose RTL project\\\" title=\\\"Choose RTL project\\\">\\n<img src=\\\"resources/005_vivado_select_nexys4_ddr.png\\\" alt=\\\"Select Nexys4 DDR\\\" title=\\\"Select Nexys4 DDR\\\">\\n<img src=\\\"resources/006_vivado_project_summery.png\\\" alt=\\\"Project summary\\\" title=\\\"Project summary\\\">\\n<img src=\\\"resources/007_vivado_ide.png\\\" alt=\\\"Basc Vivado IDE\\\" title=\\\"Vivado IDE\\\"></p>\\n<p>The image</p>\\n<img alt=\\\"Client Logo\\\" style='width:50px' title=\\\"Client Logo\\\" src='resources/001_start_vivado.png' />\\n<p>Next</p>\\n<h2>Initializing version control (git)</h2>\\n<p>After completing the wizard, open the TCL tab and type the following commands:</p>\\n<ol>\\n<li>go to your project folder: cd /home/<username>/Xilinx/projects/basic_microblaze/</li>\\n<li>create a src and blockdesign dir. The src directory will contain all the files that are under version control: exec mkdir -p src/blockdesign</li>\\n<li>create a directory for vhdl files: exec mkdir -p src/design</li>\\n<li>create a folder for the SDK (C sources): exec mkdir -p src/sdk/workspace</li>\\n<li>create a folder for the SDK hardware definition: exec mkdir -p src/sdk/hardware</li>\\n<li>initialize the repository: git init</li>\\n<li>apply first commit: git commit -am \\\"first commit\\\" </li>\\n</ol>\\n<h2>Create constraints file (XDC)</h2>\\n<p>Add the empty XDC in the  project folder: .../basic_microblaze/src/design/design.xdc. In the TCL window run\\ngit add src/design/design.xdc</p>\\n<h1>Create the block design</h1>\\n<p>First step is to specify the architecture of the synthesized FPGA hardware blocks. Pay careful attention to configuration of the clock wizard, the MIG7 memory generator and polarity of reset signals. </p>\\n<p>Add the block design in the  project folder: /home/<username>/Xilinx/projects/basic_microblaze/src/blockdesign</p>\\n<h2>Microblaze</h2>\\n<p>Click on the '+' button and search for \\\"Microblaze\\\". After adding the Microblaze processor click on it to customize it:</p>\\n<ol>\\n<li>wizard page 1: enable the Debug Module (MDM) and enable caches.</li>\\n<li>wizard page 2: next</li>\\n<li>wizard page 3: select 16 kB instruction cache, and a 16 kB data cache.</li>\\n<li>wizard page 4: next</li>\\n<li>wizard page 5: Enable AXI data interface</li>\\n</ol>\\n<p>A green box will appear containing a link to \\\"Run block automation\\\". Clicking this Vivado will create additional IP blocks to support the Microblaze. When clicking \\\"Run block automation\\\" a settings window will open:</p>\\n<ol>\\n<li>Choose local memory 16 KB</li>\\n<li>Choose cache configuration: 16 KB</li>\\n<li>Choose Debug module Debug Only</li>\\n<li>Select enable Peripheral AXI Port</li>\\n<li>Select enable interrupt controller</li>\\n<li>Choose to create a new clocking wizard (100 MHz)</li>\\n</ol>\\n<p>The block design will now contain a Microblaze, Local memory, Processor System Reset, Interrupt controller (and concat block), Clocking wizard, AXI interconnect.</p>\\n<ol start=\\\"7\\\">\\n<li>Later another Processor System Reset block will be added. Rename the existing one to \\\"cpu_sys_reset\\\".</li>\\n</ol>\\n<h2>Clocking wizard</h2>\\n<p>Double click the \\\"clocking wizard\\\" to customize it:</p>\\n<ol>\\n<li>On the clock options page select \\\"single ended clock capability\\\" for the row \\\"primary\\\".</li>\\n<li>On the output clocks page:\\n2.1. Add two extra output clocks besides the existing 100 MHz clock: 200 MHz and 50 MHz.\\n2.2 Also on the this page choose the reset type: active low</li>\\n<li>Finish the wizard and right click the \\\"clk_in1\\\" port. Select ake inputs external. A new external input will be created. Rename it to \\\"CLK100MHZ\\\"</li>\\n<li>Right click the \\\"resetn\\\" port. Select make inputs external. A new external input will be created. Rename it to \\\"reset_n\\\"</li>\\n<li>Connect the \\\"reset_n\\\" port to the  \\\"ext_reset_n\\\" port of the Processor System Reset block.\\nThese clocks are generated using the FPGA's built in MMCM which can be thought of as a kind of PLL. The 200 MHz will be used for the DDR2 controller, the 50 MHz for the Quad SPI Flash and external Ethernet LAN8720A chip. The reset button in on the Nexys4 DDR will output a '0' when pressed. To use this button for resetting the various IP blocks every reset input port has to be configured as \\\"active low\\\". Renaming the ports is required to match the physical pin constraints in the XDC file. Add the following rows to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN E3 IOSTANDARD LVCMOS33} [get_ports CLK100MHZ]\\ncreate_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports CLK100MHZ]\\nset_property -dict {PACKAGE_PIN C12 IOSTANDARD LVCMOS33} [get_ports reset_n]</p>\\n<h2>AXI SmartConnect</h2>\\n<p>In a first attempt I added a DDR2 controller. The 'run block automation' reappeared. After running it an \\\"AXI SmartConnect\\\" appeared. I wondered why this was a different component comparing it to the \\\"AXI interconnect\\\" created by the Microblaze Block Automation. The documentation notes that both \\\"Axi SmartConnect\\\"  and \\\"Axi interconnect\\\" have similar functionality and that \\\"Axi SmartConnect\\\" supersedes \\\"Axi interconnect\\\". In all the examples I saw using Microblaze and DDR RAM there were two \\\"Axi interconnect/smartconnect\\\" blocks. In this design I will use one to keep things simple. Have to check later how this impacts performance.</p>\\n<ol>\\n<li>Delete the existing \\\"AXI interconnect\\\"</li>\\n<li>Add an \\\"AXI SmartConnect\\\"</li>\\n</ol>\\n<p>Double click the \\\"AXI SmartConnect\\\" it to customize:</p>\\n<ol>\\n<li>Select the number of slaves: 3</li>\\n<li>Select the number of masters: 7</li>\\n<li>Select the number of clocks: 2</li>\\n<li>Enable reset input: has resetn input: 1</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect microblaze M_AXI_DP, M_AXI_DC, M_AXI_IC to the input AXI slave interfaces: S00_AXI, S01_AXI, S02_AXI</li>\\n<li>Connect the \\\"clockin wizard\\\" 100Mhz clock (clk_out1) to the aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"interconnect_aresetn\\\" to the resetn input</li>\\n</ol>\\n<p>The AXI SmartConnect is configures such that all the memory interfacing (including IO mapped peripherals) runs through it. Two clocks are required because the DDR2 controller is part of a different clock domain.</p>\\n<h2>AXI GPIO</h2>\\n<p>The AXI GPIO IP block is used to control general purpose input/output pins. In our case only outputs are used to control an RGB LED on the Nexys4 DDR board. Add the AXI GPIO block, double click to configure:</p>\\n<ol>\\n<li>Select \\\"All outputs\\\"</li>\\n<li>Select \\\"GPIO width\\\" as 3 pins.</li>\\n<li>Select default value: \\\"0x10\\\".</li>\\n<li>Finish the wizard and right click the GPIO port. Select make external. A new external output will be created. Rename it to \\\"GPIO\\\"</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the M00_AXI of the \\\"AXI SmartConnect\\\" to the S_AXI input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the s_axi_aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>Add the following rows to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[0]}]\\nset_property -dict {PACKAGE_PIN R11 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[1]}]\\nset_property -dict {PACKAGE_PIN N16 IOSTANDARD LVCMOS33} [get_ports {GPIO_tri_o[2]}]</p>\\n<p>The GPIO width is chosen to 3 to be able to control the Red, Green and Blue channel of the RGB LED. THe output is renamed to \\\"GPIO\\\" so that physical pin constraints can be configured (later on) in the XDC file.</p>\\n<h2>AXI UARTlite</h2>\\n<p>The AXI UARTlite IP block allows the processor to communicate via serial port to the outside world. The C/C++ print routines will make use of this serial port. Add the IP and customize it by double clicking:</p>\\n<ol>\\n<li>Select 38400 as a Baudrate</li>\\n<li>Finish the wizard and right click the UART port. Select make external. A new external output will be created. Rename it to \\\"UART\\\"</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the M01_AXI of the \\\"AXI SmartConnect\\\" to the S_AXI input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the s_axi_aclk pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>The interrupt pin is not connected.</li>\\n<li>Add the following pin constraints to the XDC file:</li>\\n</ol>\\n<p>  set_property -dict {PACKAGE_PIN D4 IOSTANDARD LVCMOS33} [get_ports UART_txd]\\nset_property -dict {PACKAGE_PIN C4 IOSTANDARD LVCMOS33} [get_ports UART_rxd]</p>\\n<p>The serial port is accessible via USB. It uses the same USB port which is also used for JTAG and FPGA/Microblaze programming.</p>\\n<h2>AXI Interrupt controller</h2>\\n<p>The interrupt controller signals the Microblaze once an external event needs to be handled by the processor. Interrupts are generated by the Timer and Ethernet component. </p>\\n<ol>\\n<li>Add a Concat block if it is not already connected to the interrupt controller.</li>\\n<li>Connect \\\"dout\\\" of the Concat block to intr of the interrupt controller</li>\\n<li>Connect \\\"interrupt\\\" output of the Interrupt Controller to the Microblaze \\\"interrupt\\\" input.</li>\\n<li>Connect the \\\"clocking wizard\\\" 100Mhz clock (clk_out1) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"peripheral_aresetn\\\" to the s_axi_aresetn input</li>\\n<li>Connect the \\\"processor_clk\\\" input to \\\"s_axi_aclk\\\".</li>\\n<li>Connect the \\\"processor system reset\\\" output port \\\"mb_reset\\\" to the processor_rst input.</li>\\n<li>Connect the axi bus \\\"s_axi\\\" input to the \\\"M02_axi\\\" output of the AXI SmartConnect.</li>\\n</ol>\\n<p>Note that the intr input is initially displayed as intr[0:0]. This will update automatically to intr[0:1] once the design is validated.</p>\\n<h2>AXI Timer</h2>\\n<p>The Timer component implements a programmable timer. Add an AXI Time IP block. Configure by double clicking:</p>\\n<ol>\\n<li>The Default settings should be ok.</li>\\n</ol>\\n<p>Connect the block:</p>\\n<ol>\\n<li>Connect the \\\"M03_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</li>\\n<li>Connect the interrupt pin to \\\"in0\\\" of the Concat block (which is connected to the interrupt controller).</li>\\n</ol>\\n<h2>AXI Ethernetlite</h2>\\n<p>The Ethernetlite component presents a memory mapped ethernet device to the Microblaze. In the C user application running on the Microblaze the lwIP stack will be used to connect to the Internet.  The Ethernetlite component presents a MII interface. The Nexys4 DDR contains a LAN8720A chip which already implements part of this interface. That chip presents a so called reduced MII interface. Xilinx has a MII_to_RMII IP block available to convert. Add both the \\\"AXI Ethernetlite\\\" and \\\"Ethernet PHY MII to Reduced MII\\\" to the block design.</p>\\n<p>Configure the AXI Ethernetlite block:</p>\\n<ol>\\n<li>Enable Internal Loopback</li>\\n</ol>\\n<p>Create two external output ports:</p>\\n<ol>\\n<li>Create an output port \\\"ETH_RST_N\\\" of type 'other'.</li>\\n<li>Create an output port \\\"ETH_CLK\\\" of type 'clock'.</li>\\n</ol>\\n<p>Connect the blocks:</p>\\n<ol>\\n<li>Connect the \\\"M04_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</li>\\n<li>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</li>\\n<li>Connect the interrupt \\\"ip2intc_irpt\\\" pin to \\\"in1\\\" of the Concat block (which is connected to the interrupt controller).</li>\\n<li>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ref_clk\\\" pin.</li>\\n<li>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ETH_CLK\\\" external pin.</li>\\n<li>Connect the Ethernetlite port \\\"MII\\\" to the \\\"MII\\\" port of the MII_to_RMII block.</li>\\n<li>Right click the \\\"MDIO\\\" port, make it external. Rename it to \\\"MDIO\\\"</li>\\n<li>Right click the \\\"RMII_PHY_M\\\" port, make it external. Rename to \\\"RMII_PHY_M\\\".</li>\\n<li>Expand the \\\"MII\\\" port of the Ethernetlite device.\\n9.1 Connect the \\\"phy<em>rst</em>n\\\" pin of the MII bus to the \\\"rst<em>n</em>rmii\\\" of the MII_to_RMII block.\\n9.2 Connect the \\\"phy<em>rst</em>n\\\" pin of the MII bus to the \\\"ETH<em>RST</em>N\\\" external pin.\\n9.3 Collapse the \\\"MII\\\" port.</li>\\n<li>Add the following constraints to the XDC file:\\n`\\nset_property -dict {PACKAGE_PIN C9 IOSTANDARD LVCMOS33} [get_ports MDIO_mdc]\\nset_property -dict {PACKAGE_PIN A9 IOSTANDARD LVCMOS33} [get_ports MDIO_mdio_io]\\nset_property -dict {PACKAGE_PIN B3 IOSTANDARD LVCMOS33} [get_ports ETH_RST_N]\\nset_property -dict {PACKAGE_PIN D9 IOSTANDARD LVCMOS33} [get_ports RMII_PHY<em>M\\\\</em>crs_dv]\\nset_property -dict {PACKAGE_PIN C10 IOSTANDARD LVCMOS33} [get_ports RMII_PHY<em>M\\\\</em>rx_er]\\nset_property -dict {PACKAGE_PIN C11 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY<em>M\\\\</em>rxd[0]}]\\nset_property -dict {PACKAGE_PIN D10 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY<em>M\\\\</em>rxd[1]}]\\nset_property -dict {PACKAGE_PIN B9 IOSTANDARD LVCMOS33} [get_ports RMII_PHY_M_tx_en]\\nset_property -dict {PACKAGE_PIN A10 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY_M_txd[0]}]\\nset_property -dict {PACKAGE_PIN A8 IOSTANDARD LVCMOS33} [get_ports {RMII_PHY_M_txd[1]}]\\nset_property -dict {PACKAGE_PIN D5 IOSTANDARD LVCMOS33} [get_ports ETH_CLK]\\n#set_property -dict { PACKAGE_PIN B8    IOSTANDARD LVCMOS33 } [get_ports { ETH_INTN }]; #IO_L12P_T1_MRCC_16 Sch=eth_intn</li>\\n</ol>\\n<p>In most tutorials the 50MHz clock is used to drive the LANxxx chip and the MII_to_RMII block. According to some recommendations the  MII_to_RMII block introduces a clock delay. Ideally the clocking wizard should be used to create two 50 MHz clocks, one with a phase delay. The un-delayed clock is connected to the MII_to_RMII block. The delayed clock is connected to the LANxxx chip. Furthermore there is a discussion if the LANxxx can be clocked used a synthesized 50MHz clock as there the clock jitter would be outside the LANxxx requirements.  </p>\\n<h2>AXI Quad SPI</h2>\\n<p>The Quad SPI component is connected to the external Quad SPI Flash (A Spansion S25FL128S). It allows the FPGA to retrieve its bit stream from the Flash chip. Furthermore the Microblaze will be able to boot the user application from flash. Add a Quad SPI IP block and configure it:</p>\\n<ol>\\n<li>Select mode: quad</li>\\n<li>Select the Spansion slave device.</li>\\n</ol>\\n<p>Connect the Quad SPI block as follows:</p>\\n<ol>\\n<li>\\n<p>Connect the \\\"M05_AXI\\\" of the AXI SmartConnect to the \\\"S_AXI\\\" input.</p>\\n</li>\\n<li>\\n<p>Connect the Clocking Wizard \\\"clk_out1\\\" (100Mhz clock) to the \\\"s_axi_aclk\\\" pin.</p>\\n</li>\\n<li>\\n<p>Connect the Processor System Reset output port \\\"peripheral_aresetn\\\" to the \\\"s_axi_aresetn\\\" input.</p>\\n</li>\\n<li>\\n<p>Connect the Clocking Wizard \\\"clk_out3\\\" (50Mhz clock) to the \\\"ext_spi_clk\\\" pin.</p>\\n</li>\\n<li>\\n<p>Right click the \\\"SPI_0\\\" port, make it external and rename to \\\"QSPI_FLASH\\\".</p>\\n</li>\\n<li>\\n<p>Add the following pin constraints to the XDC file:</p>\\n<pre><code>set\\\\_property -dict {PACKAGE\\\\_PIN K17 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io0\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN K18 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io1\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN L14 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io2\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN M14 IOSTANDARD LVCMOS33} [get\\\\_ports QSPI\\\\_FLASH\\\\_io3\\\\_io]\\nset\\\\_property -dict {PACKAGE\\\\_PIN L13 IOSTANDARD LVCMOS33} [get\\\\_ports {QSPI\\\\_FLASH\\\\_ss\\\\_io[0]}]\\n</code></pre>\\n</li>\\n</ol>\\n<h2>AXI DDR2 controller</h2>\\n<p>The Memory Interface Generator (MIG7) is used to create a DDR2 controller for the Micron MT47H64M16HR-25:H RAM chip on the Nexys4 DDR board. The Microblaze will use a BRAM based bootloader to copy the user application from Flash to DDR2 Ram. The DDR2 controller requires very precise timing parameters. These are specified in the <a href=\\\"\\\">DDR2 RAM tutorial</a>. Add a MIG7 component and double click to configure:</p>\\n<ol>\\n<li>At this introduction page click Next.</li>\\n<li>Again click next.</li>\\n<li>Select the pin compatible FPGA. The Nexys4 DDR uses the xc7a100ti-csg324.</li>\\n<li>Choose DDR2 as controller type.</li>\\n<li>On the \\\"Controller options\\\" page select:\\n5.1. Clock period: 3077\\n5.2. Memory part: MT47H64M16HR-25E\\n5.3. Datawidth: 16 bits\\n5.4. Ordering: Normal</li>\\n<li>On the \\\"AXI Parameter\\\" page configure the AXI interface:\\n6.1. Data width: 128\\n6.2. Enable narrow burst support (set to one).</li>\\n<li>On the \\\"Memory Options\\\" page choose:\\n7.1. Set the \\\"input clock period\\\" to 100 MHz. If this setting is missing chances are that you run across a bug in the Memory Interface Generator (MIG7). When running Vivado 2018.2 from Ubuntu use the right locale settings. Restart Vivado from the terminal and first execute: export LC<em>NUMERIC=en</em>US.utf8\\n7.2.  RTT-ODT to be 50 ohms. </li>\\n<li>On the \\\"FPGA options\\\" page:\\n8.1. select \\\"no buffer\\\" for both system clock and reference clock. \\\"no buffer\\\" means that we can connect clocks generated by the clocking wizard.\\n8.2. Set the system reset polarity to active low.\\n8.3. Enable usage of \\\"Internal vref\\\".</li>\\n<li>On the \\\"Extended FPGA options\\\" choose the Internal termination impedance to be 50 omhs.</li>\\n<li>On the \\\"IO Planning\\\" page select fixed pin out as we want to connect the controller to the external RAM chip.</li>\\n<li>On the \\\"Pin selection\\\" page, type the pin numbers, next click validate. Refer to the XDC constraints below for the actual pin values. The pin selection page does not fit on one page, and you have to scroll to get to all the pins. Be care full when scrolling: scrolling when the mouse is above a pin selection drop down changes the pin!</li>\\n<li>On the \\\"System signals\\\" do not select anything.</li>\\n<li>Verify that the summary report is similar to the screenshot.</li>\\n<li>The last pages \\\"simulation options:\\\": accept, \\\"pcb information\\\": next, \\\"design notes\\\": generate.</li>\\n</ol>\\n<p>The DDR RAM controller will generate its own clock on the \\\"ui_clk\\\" pin. The DDR RAM controller needs its own system reset logic as part of this clock domain. Add another \\\"Processor System Reset\\\", rename it to FPGA_sys_reset\\\".</p>\\n<p>Connect the DDR RAM controller:</p>\\n<ol>\\n<li>Connect the AXI SmartConnect pin \\\"M06\\\\AXI\\\" to the S_AXI pin.</li>\\n<li>Connect the external \\\"reset_n\\\" pin to the \\\"sys_rst\\\" pin of the FPGA_sys_reset block.</li>\\n<li>Connect the clocking wizard \\\"clk_out1\\\" (100 MHz) clock to \\\"sys_clk_i\\\" of the Ram controller.</li>\\n<li>Connect the clocking wizard \\\"clk_out2\\\" (200 MHz) clock to \\\"clk_ref_i\\\" of the RAM controller. </li>\\n<li>Right click the DDR controller \\\"DDR2\\\" pin and make it external. Rename the external pin to \\\"DDR2\\\".</li>\\n<li>Connect the DDR controller \\\"ui_clk_sync_rst\\\" to the \\\"ext_reset_in\\\" of the FPGA_sys_reset block.</li>\\n<li>Connect the DDR controller \\\"ui_clk\\\" clock to the \\\"slowest_sync_clk\\\" of the FPGA_sys_reset block.</li>\\n<li>Connect this clock also to the \\\"aclk1\\\" pin of the AXI SmartConnect.</li>\\n<li>Connect the \\\"mmcm_locked\\\" of the DDR Controller to the  \\\"dcm_locked\\\" pin of the FPGA_sys_reset block.</li>\\n<li>The DDR Controller pin \\\"int_calib_complete\\\" is left unconnected.</li>\\n<li>Connect the FPGA_sys_reset pin \\\"peripheral_aresetn\\\" to the DDR controller \\\"aresetn\\\" pin. </li>\\n</ol>\\n<p>In some articles it is specified that one should not use a clocking wizard generated clock connected to the DDR controller as it would have too much jitter. In spite of this advice I have used the 200 MHz output of the clock wizard. The following pin constraints are required connecting the DDR RAM chip.</p>\\n<pre><code>    set\\\\_property -dict {PACKAGE\\\\_PIN R7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R8 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[3]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V7 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[4]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[5]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[6]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[7]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[8]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[9]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[10]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[11]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[12]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[13]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[14]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dq[15]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dm[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dm[1]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U9 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_p[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V9 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_n[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN U2 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_p[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN V2 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_dqs\\\\_n[1]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[12]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN K5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[11]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[10]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[9]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[8]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[7]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[6]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P5 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[5]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[4]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN T1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[3]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_addr[0]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN R1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[2]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[1]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN P2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ba[0]}]\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L6 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ck\\\\_p[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L5 IOSTANDARD DIFF\\\\_SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_ck\\\\_n[0]}]\\n\\n\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N4 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_ras\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN L1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_cas\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN N2 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports DDR2\\\\_we\\\\_n]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M1 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_cke[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN M3 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_odt[0]}]\\n    set\\\\_property -dict {PACKAGE\\\\_PIN K6 IOSTANDARD SSTL18\\\\_II} [get\\\\_ports {DDR2\\\\_cs\\\\_n[0]}]\\n</code></pre>\\n<h2>Address map</h2>\\n<p>The connected AXI devices are either memory type devices or memory mapped IO devices. We have to specify the Microblaze memory map so that the AXI devices can be accessed by the bootloader and user application. Click the address editor tab.</p>\\n<ol>\\n<li>Right click Data area, unmapped slaves. For each of the following devices select assign address: ethernetlite, gpio, uartlite, timer, quad spi, mig7.</li>\\n<li>The  \\\"Instructions\\\" mapped devices should only contain the local memory and the mig7 device. Select any other mapped devices and rigth click \\\"exclude\\\". </li>\\n</ol>\\n<p>Check that the Microblaze local memory sections for both data and instructions are at least 32 kB.</p>\\n<h1>XDC pin constraints</h1>\\n<p>The XDC file specifies constraints on the physical FPGA pins. Digilent provides a XDC file for the Nexys4 DDR. This file is adapted to map the input and output ports of the block design to physical pins. The [XDC constraints file] is based upon a reference of Digilent. When the block design is completed and synthesized you can run the \\\"get_ports\\\" command in the tcl window. The names of all the different block design input and output pins will then be displayed. These names have to be added to the XDC file. So if you run get_ports and \\\"OUTPUT_X\\\" is displayed then the XDC should contain a row (change the IOStandard and PACKAGE_PIN to suit your needs):</p>\\n<p>set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33} [get_ports OUTPUT_X]</p>\\n<p>Some additional constraints are required to get rid of a warning:\\nset_property CFGBVS VCCO [current_design]\\nset_property CONFIG_VOLTAGE 3.3 [current_design]</p>\\n<h1>Synthesize</h1>\\n<p>Right click \\\"mb_design\\\" in the sources pane. Click \\\"generate HDL wrapper\\\", select \\\"Let Vivado manage wrapper...\\\"</p>\\n<p>Click \\\"Run synthesis\\\" in the \\\"Flow Navigator\\\".\\nClick \\\"Run implementation\\\" ....</p>\\n<p>Click \\\"Open implemented design\\\" and select the IO ports tab. If the XDC contains no errors. It should look like the following screenshot.</p>\\n<h1>Generate bit file</h1>\\n<p>Later on the FPGA bit stream will be flashed on the Quad SPI Flash device. In order to reduce the size of the bit stream and speed up booting the bit stream can be compressed. Turn compression on by adding this to the XDC file.</p>\\n<p>Open the tools -> settings menu. Select bit stream options under project settings. Tick the \\\"-bin_file\\\" option. Open \\\"additional settings\\\" and tick \\\"enable compression\\\". A constraint will be added automatically to the XDC file:</p>\\n<p>set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]</p>\\n<p>Run the bit stream generator.</p>\\n<h1>Commit the block design to version control</h1>\\n<p>Store the current version of the  block design inside version control:</p>\\n<ol>\\n<li>git add src/blockdesign/mb_design/*</li>\\n<li>check with git status that no files under src are \\\"untracked\\\". If needed use \\\"git add\\\" to add remaining untracked files under src. Do not add these folders: basici_microblaze.cache/, basic_microblaze.hw/, basic_microblaze.runs/, basic_microblaze.xpr</li>\\n<li>git commit -am \\\"Block design done\\\"</li>\\n</ol>\\n<h1>SDK, software development</h1>\\n<p>First export the hardware definition. Select the File menu -> export -> export hardware. Enable \\\"include bit stream\\\". Choose the src/sdk/hardware folder.</p>\\n<p>Click launch \\\"SDK\\\" from the project menu. Choose the relevant src/sdk/workspace folder for as workspace. Vivado will start the SDK which is the Eclipse C/C++ development IDE. The workspace will contain the hardware definition \\\"mb_design_wrapper....\\\". Click the \\\"system.hdf\\\" file and check that the memory map is correct.</p>\\n<h2>Create bootloader and BSP.</h2>\\n<p>Create a new \\\"Application project\\\" named \\\"Bootloader\\\". In the \\\"Target software\\\" pane select \\\"Create new\\\" board support package. Name the BSP \\\"Bootloader_bsp\\\". Click \\\"next\\\" and select the \\\"SREC SPI bootloader\\\" template. Click \\\"Finish\\\".</p>\\n<h3>Configure Bootloader BSP</h3>\\n<p>Open the Bootloader_bsp project and open \\\"system.mss\\\". Click \\\"Modify this BSP's Settings\\\". Select \\\"xilisf\\\" in the navigation tree view. Set the \\\"serial_flash_family\\\" type to 5 (Spansion). Click \\\"Regenerate BSP sources\\\". </p>\\n<h3>Configure Bootloader</h3>\\n<p>Open the \\\"Bootloader\\\" project and edit the \\\"blconfig.h\\\" file. The bootloader needs to know the address in SPI flash where the user application resides. Remove the warning and change the \\\"FLASH_IMAGE_BASEADDR\\\" to 0x003D0900. Select the linker \\\"ldscript.ld\\\" file. Set the stack size to 0x200. Check that all segments are assigned to BRAM local memory (and not the external DDR RAM as this memory will receive the user application loaded from the Flash memory). </p>\\n<p>In bootloader.c check that SPI_DEVICE_ID is set to XPAR_SPI_0_DEVICE_ID. The warning line above it can then be removed.</p>\\n<p>In bootloader.c the VERBOSE flag should be defined (by default). This will cause the bootloader to print messages while the bootloading is in progress. The print output will be streamed over the UARTlite interface. The print commands unfortunately slow down the bootloading. A small modification helps. Replace the contents of the function \\\"display_progress\\\" by:</p>\\n<pre><code>print(\\\".\\\")\\n</code></pre>\\n<p>This will speedup things while still giving some insight in the bootloading progress. After saving Eclipse will rebuild the Bootloader. If all is well the Bootloader should compile without errors now.</p>\\n<h3>Programming the FPGA</h3>\\n<p>In this step the hardware design including bootloader will be programmed into flash such that the FPGA loads it every time it boots. Configure the SPI jumper on the Nexys4 DDR development kit. This allows the FPGA to load its bit file from the SPI flash. The FPGA bit file contains the configuration of the FPGA including initial contents of the Microblaze local BRAM.  Next connect the Nexys4 DDR board via the JTAG usb connector. Start a serial terminal (eg. gtkterm) and select the port (eg. /dev/ttyUSB1) and set the baud rate to 38400 (as configured in the UARTlite block design).</p>\\n<p>Run the program FPGA command from the Xilinx menu. Select the bootloader.elf file (in the Bootloader/Debug project) in stead of \\\"bootloop\\\". Selecting \\\"program\\\" will generate a download.bit file in the \\\"mb_design_wrapper_hw_platform_0\\\" project. </p>\\n<p>After the programming completes, in the serial terminal you should see the bootloader starting (and failing).</p>\\n<h3>Flashing the FPGA bitstream.</h3>\\n<p>Next click the \\\"Program Flash\\\" menu item in the Xilinx menu. Select the download.bit files as \\\"image file\\\". The offset should be 0. The flash type is \\\"s25fl128sxxxxx0-spi-x1_x2_x4\\\". Check \\\"verify after flash\\\". And finish by clicking \\\"Program\\\".</p>\\n<p>After flashing you can restart the Nexys4 DDR by pressing the \\\"prog\\\" button. Again the bootloader should start and fail. Note that while the FPGA can load its bit file from flash it can also still be programmed as usual using JTAG.</p>\\n<h2>Create user application</h2>\\n<p>Create a new project, named TestApp. Select Create new board support package named \\\"TestApp_bsp\\\". Click next and select the \\\"Peripheral tests\\\" template.</p>\\n<h3>Configure TestApp BSP</h3>\\n<p>Open the TestApp_bsp project and open \\\"system.mss\\\". Click \\\"Modify this BSP's Settings\\\". Enable \\\"xilisf\\\" and \\\"lwip202\\\" in the supported libraries pane. Select \\\"xilisf\\\" in the navigation tree view. Set the \\\"serial_flash_family\\\" type to 5 (Spansion). S</p>\\n<p>Click \\\"Regenerate BSP sources\\\". Probably the build will fail. There is a bug in Vivado 2018.2 lwip202, it does not define some xadapter code required to compile using EthernetLite. There is a <a href=\\\"\\\">patch</a> available. The patch has been applied manually in the example repository. Be care full not to regenerate the BSP sources as this will remove the patch.</p>\\n<p>The changes can be viewed by looking at this diff: git diff 69b53308d4d4690ab77b53d72262df3ee429e0b d45cd8645e9563a86cef6648e0a15483d39f63f9 '*.c'</p>\\n<h3>Configure the TestApp</h3>\\n<p>The peripherial test application does not need any configuring.</p>\\n<h3>Flashing the user application</h3>\\n<p>Click the \\\"Program Flash\\\" menu item in the Xilinx menu. Select the TestApp.elf file \\\"image file\\\". The offset should be 0x003D0900 (as configured in the bootloader). The flash type is \\\"s25fl128sxxxxx0-spi-x1_x2_x4\\\". Tick \\\"convert elf file to bootable SREC...\\\". Check \\\"verify after flash\\\". And finish by clicking \\\"Program\\\".</p>\\n<p>Reset the Nexys4 DDR by pressing the \\\"prog\\\" button. The bootloader should start loading and eventually run the user application. The user application will print various test messages. The RGB LED connected to the GPIO should react to one of the tests. The last tests will test the Ethernetlite interface (you'll see the Ethernet LEDs blinking twice).</p>\\n<h2>Committing the SDK code</h2>\\n<p>First add .gitignore files to a number of folders to ignore logging files:</p>\\n<p>  src/sdk/workspace/Bootloader_bsp/.gitignore:\\n*.o\\n*.a</p>\\n<p>  src/sdk/workspace/TestApp_bsp/.gitignore:\\n*.o\\n*.a</p>\\n<p>  src/sdk/workspace/mb<em>design</em>wrapper<em>hw</em>platform_0/.gitignore:\\ncache</p>\\n<p>  src/sdk/workspace/.metadata/.gitignore:\\n*.log\\n.lock</p>\\n<p>  src/sdk/.gitignore:\\n*.jou\\n*.log</p>\\n<p>  git add src/sdk/hardware/mb_design_wrapper.hdf\\ngit add src/sdk/workspace/Bootloader\\ngit add src/sdk/workspace/Bootloader_bsp\\ngit add src/sdk/workspace/TestApp\\ngit add src/sdk/workspace/TestApp_bsp\\ngit add src/sdk/workspace/mb_design_wrapper_hw_platform_0\\ngit add src/sdk/workpace/.metadata</p>\\n<p>  git commit --message \\\"Added bootloader and test application with patched lwip202\\\"</p>\\n<h1>Conclusion</h1>\\n<ol>\\n<li>Creating the basic Microblaze architecture running requires many configuration steps. While writing this tutorial I had one working reference project and created a new project describing each step. The first time I ended up with a bootloader that did not fit in the BRAM. Somehow, somewhere the Microblaze cache size was set to 16 kB, instead of the required 32 kB. I suspect the block automation step to be the culprit. Luckily by checking the linker script in the SDK this was easy to find and correct.</li>\\n<li>When working in Linux check your Locale settings as described in the tutorial. If set wrongly the MIG7 wizard will not snow essential settings.</li>\\n<li>The Eclipse SDK crashed a few times resulting in a locked SDK which could not be restarted. Remove .lock files from the .metadata in src/sdk/workspace to get it working again. </li>\\n</ol>\\n<p>The VHDL code can be found in the <a href=\\\"https://github.com/dwjbosman/basic_microblaze\\\">Basic_microblaze</a> repository.</p>\",\"timeToRead\":28,\"excerpt\":\"Table of Contents Create the project Initializing version control (git) Create constraints file (XDC) Create the block design Microblazeâ€¦\",\"frontmatter\":{\"title\":\"Basic Microblaze with bootloader setup\",\"cover\":\"/logos/sine-article.jpg\",\"date\":\"2018-11-01 09:00\",\"category\":\"FPGA\",\"tags\":[\"VHDL FPGA SDK\"]},\"fields\":{\"nextTitle\":\"First Post\",\"nextSlug\":\"/first-post\",\"prevTitle\":\"VHDL sine wave oscillator\",\"prevSlug\":\"/vhdl-sine-wave-oscillator\",\"slug\":\"/basic-microblaze-with-bootloader-setup\"}}},\"pathContext\":{\"slug\":\"/basic-microblaze-with-bootloader-setup\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/basic-microblaze-with-bootloader-setup.json\n// module id = 450\n// module chunks = 110947099173558"],"sourceRoot":""}